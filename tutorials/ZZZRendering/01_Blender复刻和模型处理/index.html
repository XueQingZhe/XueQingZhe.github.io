<!DOCTYPE html> <html lang="zh-CN"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Blender复刻和模型处理 | 吟处雪 轻遮 </title> <meta name="author" content="吟处雪 轻遮"> <meta name="description" content="Blender复刻和模型处理"> <meta name="keywords" content="technical-artist, shader, rendering, unity, unreal-engine, pbr, toon-shading"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://xueqingzhe.github.io/tutorials/ZZZRendering/01_Blender%E5%A4%8D%E5%88%BB%E5%92%8C%E6%A8%A1%E5%9E%8B%E5%A4%84%E7%90%86/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/spotlight.js@0.7.8/dist/css/spotlight.min.css" integrity="sha256-Dsvkx8BU8ntk9Iv+4sCkgHRynYSQQFP6gJfBN5STFLY=" crossorigin="anonymous"> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">吟处雪</span> 轻遮 </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/books/">books </a> </li> <li class="nav-item active"> <a class="nav-link" href="/tutorials/">tutorials <span class="sr-only">(current)</span> </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Blender复刻和模型处理</h1> <p class="post-meta"> Created on December 21, 2025 </p> <p class="post-tags"> <i class="fa-solid fa-calendar fa-sm"></i> 2025   ·   <i class="fa-solid fa-hashtag fa-sm"></i> shader   <i class="fa-solid fa-hashtag fa-sm"></i> rendering   <i class="fa-solid fa-hashtag fa-sm"></i> unity   <i class="fa-solid fa-hashtag fa-sm"></i> tutorials   <i class="fa-solid fa-hashtag fa-sm"></i> blender   ·   <i class="fa-solid fa-tag fa-sm"></i> ZZZ渲染复刻 </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="安装blendermmd导入插件">安装BlenderMMD导入插件</h1> <h2 id="方法1-github下载">方法1 Github下载</h2> <p><a href="https://github.com/UuuNyaa/blender_mmd_tools/tree/v4.2.2?tab=readme-ov-file" rel="external nofollow noopener" target="_blank">https://github.com/UuuNyaa/blender_mmd_tools/tree/v4.2.2?tab=readme-ov-file</a></p> <h2 id="方法2-blender内置下载">方法2 Blender内置下载</h2> <p><strong><em>内置下载或者到Blender插件社区下载</em></strong> 社区地址：<a href="https://extensions.blender.org/" rel="external nofollow noopener" target="_blank">https://extensions.blender.org/</a> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241230213258.png" alt="图片"></p> <h1 id="模型处理">模型处理</h1> <h2 id="导入">导入</h2> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020241230213609.png" alt="图片"></p> <h2 id="删除无用">删除无用</h2> <p><strong><em>joints（关节点）和rigidbodies（刚体）</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241230213754.png" alt="图片"></p> <h2 id="多余材质合并">多余材质合并</h2> <p><strong><em>面，齿，舌，口合并，编辑模式下材质面板点一下直接选择就行，最后选择面，点击指定</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241230214738.png" alt="图片"> <strong><em>合并后物体模式下删除材质槽</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241230215139.png" alt="图片"> <strong><em>眼睛合并到一起</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241230215327.png" alt="图片"> <strong><em>眉毛合并到一起</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241230215501.png" alt="图片"> <strong><em>眼睛高光和透贴不要删除</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241230215737.png" alt="图片"> <strong><em>头发（刘海）需要拆下来，做眼睛透过头发效果</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241230220009.png" alt="图片"> <strong><em>不需要分离，选出来之后直接新建一个材质头发指定上</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241230220736.png" alt="图片"> <strong><em>将头发，肌肤，黑丝都合并到饰品里，然后删掉其他的</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241230220911.png" alt="图片"></p> <h2 id="生成一套平滑法线用于描边">生成一套平滑法线用于描边</h2> <p><strong><em>可以存在UV里面或者在定点色里面</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241230221247.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241230221351.png" alt="图片"></p> <h3 id="新建python脚本">新建python脚本</h3> <p><strong><em>注意：mesh = bpy.data.meshes[‘星見雅’]，这里的名称是网格体名称</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241230234721.png" alt="图片"> <strong><em>因为是UV存值，所以需要将点位置从3维转换到2维，使用八面体映射</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250104210302.png" alt="图片"></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
</pre></td> <td class="rouge-code"><pre><span class="kn">import</span> <span class="n">bpy</span>  
<span class="kn">from</span> <span class="n">mathutils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="n">math</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="c1">#创建空字典列表list
</span><span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1">#获取模型Mesh
</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">bpy</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">meshes</span><span class="p">[</span><span class="sh">'</span><span class="s">星見雅</span><span class="sh">'</span><span class="p">]</span>

<span class="c1">#calc_tangents：
#在网格中计算每个顶点的切线（tangent）、双切线（bitangent）和法线（normal），以便后续的方向相关计算。
</span><span class="n">mesh</span><span class="p">.</span><span class="nf">calc_tangents</span><span class="p">(</span><span class="n">uvmap</span> <span class="o">=</span> <span class="sh">'</span><span class="s">UVMap</span><span class="sh">'</span><span class="p">)</span>

<span class="c1">#计算两个向量之间的夹角
# a·b = |a||b|cosθ
# θ = arccos(a·b / (|a||b|))
# 这里返回的弧度值  θ * (π/180) ≈ xxx弧度
</span><span class="k">def</span> <span class="nf">included_angle</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nf">arccos</span><span class="p">(</span><span class="n">v0</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">v0</span><span class="p">.</span><span class="n">length</span> <span class="o">*</span> <span class="n">v1</span><span class="p">.</span><span class="n">length</span><span class="p">))</span>

<span class="c1"># 3维降为2维
</span><span class="k">def</span> <span class="nf">unitVectorToOct</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="c1"># 步骤1：计算L1范数（曼哈顿距离）
</span>    <span class="n">d</span> <span class="o">=</span> <span class="nf">abs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="nf">abs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="nf">abs</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">z</span><span class="p">)</span>
    <span class="c1"># 步骤2：通过除以L1范数进行投影到八面体表面
</span>    <span class="c1"># o 是八面体的坐标
</span>    <span class="n">o</span> <span class="o">=</span> <span class="nc">Vector</span><span class="p">((</span><span class="n">v</span><span class="p">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">d</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">d</span><span class="p">))</span>
    <span class="c1"># 步骤3：如果z是负数，需要进行特殊处理以保持连续性
</span>    <span class="k">if</span> <span class="n">v</span><span class="p">.</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># 使用折叠技术处理八面体的下半部分
</span>        <span class="n">o</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nf">abs</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">y</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">o</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">o</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nf">abs</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">x</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">o</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">o</span>

<span class="c1">#.co是coordinate的缩写，表示顶点的坐标。
# 取出模型的每一个顶点坐标，然后清空置空列表，后续存入新的坐标数据
</span><span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">mesh</span><span class="p">.</span><span class="n">vertices</span><span class="p">:</span>
    <span class="c1"># 初始化 "&lt;Vector (1.0, 2.0, 3.0)&gt;": []
</span>    <span class="nb">dict</span><span class="p">[</span><span class="nf">str</span><span class="p">(</span><span class="n">vertex</span><span class="p">.</span><span class="n">co</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># 获取模型Mesh的每一个面
# l0,l1,l2分别表示模型Mesh的每一个面中的每一个顶点数据
# l0,l1,l2这样的写法是Blender的写法，表示loop0,loop1,loop2的循环体
# mesh.loops 存储了多边形顶点的循环信息
# poly.loop_start 表示多边形顶点的循环开始索引
</span><span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">mesh</span><span class="p">.</span><span class="n">polygons</span><span class="p">:</span>
    <span class="c1">#获取模型Mesh的每一个三角面中的每一个顶点数据
</span>    <span class="n">l0</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">loops</span><span class="p">[</span><span class="n">poly</span><span class="p">.</span><span class="n">loop_start</span><span class="p">]</span> 
    <span class="n">l1</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">loops</span><span class="p">[</span><span class="n">poly</span><span class="p">.</span><span class="n">loop_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">l2</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">loops</span><span class="p">[</span><span class="n">poly</span><span class="p">.</span><span class="n">loop_start</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
    
    <span class="c1">#获取模型Mesh的每一个面中的每一个顶点数据
</span>    <span class="c1">## 顶点的主要属性：
</span>    <span class="c1">#vertex.co           顶点的3D坐标 (Vector类型，包含x,y,z)
</span>    <span class="c1">#vertex.normal       顶点的法线方向
</span>    <span class="c1">#vertex.index        顶点在mesh.vertices数组中的索引号
</span>    <span class="c1">#vertex.groups       顶点组信息（用于骨骼绑定等）
</span>    <span class="n">v0</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">l0</span><span class="p">.</span><span class="n">vertex_index</span><span class="p">]</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">l1</span><span class="p">.</span><span class="n">vertex_index</span><span class="p">]</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">l2</span><span class="p">.</span><span class="n">vertex_index</span><span class="p">]</span>

    <span class="c1">#计算向量，三角形两条边向量
</span>    <span class="n">vec0</span> <span class="o">=</span> <span class="n">v1</span><span class="p">.</span><span class="n">co</span> <span class="o">-</span> <span class="n">v0</span><span class="p">.</span><span class="n">co</span>
    <span class="n">vec1</span> <span class="o">=</span> <span class="n">v2</span><span class="p">.</span><span class="n">co</span> <span class="o">-</span> <span class="n">v0</span><span class="p">.</span><span class="n">co</span>
    
    <span class="c1">#计算向量叉积，三角形两条边向量叉乘，得到法线
</span>    <span class="n">n</span> <span class="o">=</span> <span class="n">vec0</span><span class="p">.</span><span class="nf">cross</span><span class="p">(</span><span class="n">vec1</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="p">.</span><span class="nf">normalized</span><span class="p">()</span>

    <span class="c1">#v0.co 是一个 Vector 类型，包含 (x,y,z) 坐标值
</span>    <span class="c1">#Python的字典要求键（key）必须是"可哈希的"（hashable）
</span>    <span class="c1">#Vector 类型不能直接用作字典的键
</span>    <span class="c1">#这里将顶点坐标转换为字符串，便于后续使用
</span>    <span class="c1">#k0,k1,k2是字典的Key
</span>    <span class="n">k0</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">v0</span><span class="p">.</span><span class="n">co</span><span class="p">)</span>     <span class="c1"># 将顶点0的坐标转换为字符串
</span>    <span class="n">k1</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">v1</span><span class="p">.</span><span class="n">co</span><span class="p">)</span>     <span class="c1"># 将顶点1的坐标转换为字符串
</span>    <span class="n">k2</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">v2</span><span class="p">.</span><span class="n">co</span><span class="p">)</span>     <span class="c1"># 将顶点2的坐标转换为字符串
</span>    
    <span class="c1"># 计算三角形三个顶点的权重
</span>    <span class="k">if</span> <span class="n">k0</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="c1">#计算顶点0的权重，w实际上是两向量夹角角度
</span>        <span class="n">w</span> <span class="o">=</span> <span class="nf">included_angle</span><span class="p">(</span><span class="n">v2</span><span class="p">.</span><span class="n">co</span> <span class="o">-</span> <span class="n">v0</span><span class="p">.</span><span class="n">co</span><span class="p">,</span> <span class="n">v1</span><span class="p">.</span><span class="n">co</span> <span class="o">-</span> <span class="n">v0</span><span class="p">.</span><span class="n">co</span><span class="p">)</span>
        <span class="c1"># 添加数据
</span>        <span class="nb">dict</span><span class="p">[</span><span class="n">k0</span><span class="p">].</span><span class="nf">append</span><span class="p">({</span><span class="sh">"</span><span class="s">n</span><span class="sh">"</span> <span class="p">:</span> <span class="n">n</span><span class="p">,</span> <span class="sh">"</span><span class="s">w</span><span class="sh">"</span> <span class="p">:</span> <span class="n">w</span><span class="p">})</span>
        
    <span class="k">if</span> <span class="n">k1</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nf">included_angle</span><span class="p">(</span><span class="n">v0</span><span class="p">.</span><span class="n">co</span> <span class="o">-</span> <span class="n">v1</span><span class="p">.</span><span class="n">co</span><span class="p">,</span> <span class="n">v2</span><span class="p">.</span><span class="n">co</span> <span class="o">-</span> <span class="n">v1</span><span class="p">.</span><span class="n">co</span><span class="p">)</span>
        <span class="nb">dict</span><span class="p">[</span><span class="n">k1</span><span class="p">].</span><span class="nf">append</span><span class="p">({</span><span class="sh">"</span><span class="s">n</span><span class="sh">"</span> <span class="p">:</span> <span class="n">n</span><span class="p">,</span> <span class="sh">"</span><span class="s">w</span><span class="sh">"</span> <span class="p">:</span> <span class="n">w</span><span class="p">})</span>
        
    <span class="k">if</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nf">included_angle</span><span class="p">(</span><span class="n">v1</span><span class="p">.</span><span class="n">co</span> <span class="o">-</span> <span class="n">v2</span><span class="p">.</span><span class="n">co</span><span class="p">,</span> <span class="n">v0</span><span class="p">.</span><span class="n">co</span> <span class="o">-</span> <span class="n">v2</span><span class="p">.</span><span class="n">co</span><span class="p">)</span>
        <span class="nb">dict</span><span class="p">[</span><span class="n">k2</span><span class="p">].</span><span class="nf">append</span><span class="p">({</span><span class="sh">"</span><span class="s">n</span><span class="sh">"</span> <span class="p">:</span> <span class="n">n</span><span class="p">,</span> <span class="sh">"</span><span class="s">w</span><span class="sh">"</span> <span class="p">:</span> <span class="n">w</span><span class="p">})</span>
        
<span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">mesh</span><span class="p">.</span><span class="n">polygons</span><span class="p">:</span>
    <span class="c1"># 获取每一个三角面数据 
</span>    <span class="c1">#range(poly.loop_start, poly.loop_start + 3)遍历3个点
</span>    <span class="k">for</span> <span class="n">loop_index</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">poly</span><span class="p">.</span><span class="n">loop_start</span><span class="p">,</span> <span class="n">poly</span><span class="p">.</span><span class="n">loop_start</span> <span class="o">+</span> <span class="mi">3</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">loops</span><span class="p">[</span><span class="n">loop_index</span><span class="p">]</span>
        <span class="n">vertex_index</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">vertex_index</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vertex_index</span><span class="p">]</span>
        <span class="c1">#smoothNormal初始化
</span>        <span class="n">smoothNormal</span> <span class="o">=</span> <span class="nc">Vector</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">weightSum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nf">str</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">co</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="sh">'</span><span class="s">n</span><span class="sh">'</span><span class="p">]</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="sh">'</span><span class="s">w</span><span class="sh">'</span><span class="p">]</span>
                <span class="c1">#加权平均法线的计算公式：
</span>                <span class="c1">#例如：smoothNormal = (n1 * w1 + n2 * w2 + n3 * w3) / (w1 + w2 + w3)
</span>                <span class="n">smoothNormal</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">w</span>
                <span class="n">weightSum</span> <span class="o">+=</span> <span class="n">w</span>
        <span class="k">if</span> <span class="n">smoothNormal</span><span class="p">.</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">smoothNormal</span> <span class="o">/=</span> <span class="n">weightSum</span>
            <span class="n">smoothNormal</span> <span class="o">=</span> <span class="n">smoothNormal</span><span class="p">.</span><span class="nf">normalized</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 如果计算出的平滑法线无效（长度为0），
</span>            <span class="c1"># 使用原始顶点法线作为后备方案
</span>            <span class="n">smoothNormal</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">normal</span>
        
        <span class="n">normal</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">normal</span>           <span class="c1"># 获取顶点的原始法线
</span>        <span class="n">tangent</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">tangent</span>         <span class="c1"># 获取顶点的原始切线
</span>        <span class="n">bitangent</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">bitangent</span>     <span class="c1"># 获取顶点的原始副切线
</span>
        <span class="c1"># 计算投影
</span>        <span class="c1"># 使用原始的切线空间基底，计算平滑法线在这个空间中的表示
</span>        <span class="n">x</span> <span class="o">=</span> <span class="n">tangent</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">smoothNormal</span><span class="p">)</span>       <span class="c1"># 平滑法线在原始切线方向上的投影
</span>        <span class="n">y</span> <span class="o">=</span> <span class="n">bitangent</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">smoothNormal</span><span class="p">)</span>     <span class="c1"># 平滑法线在原始副切线方向上的投影
</span>        <span class="n">z</span> <span class="o">=</span> <span class="n">normal</span><span class="p">.</span><span class="nf">dot</span><span class="p">(</span><span class="n">smoothNormal</span><span class="p">)</span>        <span class="c1"># 平滑法线在原始法线方向上的投影
</span>        
        <span class="c1">#UV数组的大小总是等于loops的数量
</span>        <span class="n">uv1</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">uv_layers</span><span class="p">[</span><span class="sh">'</span><span class="s">UVMap.001</span><span class="sh">'</span><span class="p">].</span><span class="n">uv</span><span class="p">[</span><span class="n">loop_index</span><span class="p">]</span>
        
        <span class="n">uv1</span><span class="p">.</span><span class="n">vector</span> <span class="o">=</span> <span class="nf">unitVectorToOct</span><span class="p">(</span><span class="nc">Vector</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)))</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong><em>如果使用顶点色传入的话不需要进行维度转换</em></strong></p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td> <td class="rouge-code"><pre><span class="c1"># 存入顶点色而不是UV
</span><span class="n">vertex_color_layer</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">vertex_colors</span><span class="p">.</span><span class="n">active</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">loop_index</span><span class="p">]</span>
<span class="c1"># 直接将平滑法线的分量存入顶点色
</span><span class="n">vertex_color_layer</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="n">smoothNormal</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">smoothNormal</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">smoothNormal</span><span class="p">.</span><span class="n">z</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h2 id="模型拆分">模型拆分</h2> <p><strong><em>将有形态键的面部单独拆一个网格，包含下面的目影一起拆</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241231214912.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241231214944.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241231215006.png" alt="图片"> <strong><em>清理材质</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241231215143.png" alt="图片"> <strong><em>面部一样清理一下</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241231215438.png" alt="图片"> <strong><em>去除原网格体形态键</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241231215343.png" alt="图片"> <strong><em>给虚幻引擎需要将模型拆分多一些，刘海拆分下来</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241231215833.png" alt="图片"></p> <p><strong><em>饰品和衣服也拆分下来</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241231220041.png" alt="图片"> <strong><em>因为涉及到半透明排序还有覆层材质，眼影等全部都要拆分</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241231220235.png" alt="图片"> <strong><em>拆完记得重命名和清理材质</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020241231220825.png" alt="图片"></p> <h1 id="blender内模型可以不需要拆">Blender内模型可以不需要拆</h1> <p><strong><em>合并之前的模型，刘海记得单独一个材质插槽</em></strong></p> <h1 id="材质编辑">材质编辑</h1> <h2 id="添加图像纹理">添加图像纹理</h2> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250102163210.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102162951.png" alt="图片"> <strong><em>Ctrl+G打组，并输出，更改输出接口名称</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102163650.png" alt="图片"></p> <h2 id="新建shader打组">新建shader打组</h2> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250102164312.png" alt="图片"> <strong><em>再使用自发光Shader创建一个工具组，删掉自发光节点，创建输入接口，一个为int0~3表示判断身体区域，另一个接口为布尔类型</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102165045.png" alt="图片"> <strong><em>返回上层输出接口只保留一个Shader即可</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102164830.png" alt="图片"> <strong><em>输入接口新增，直接用Tool节点拖过去生成然后改名字就行这里，BodyArea是int类型0~3，1:Face 2:Eye 3:Body</em></strong> <strong><em>这里的Color和Alpha是用来自定义混合颜色用的</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102165549.png" alt="图片"> <strong><em>返回最上层，链接贴图，修改节点名称</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102165836.png" alt="图片"></p> <h3 id="混合颜色">混合颜色</h3> <p><strong><em>进入ForwardShader组，进行混合颜色</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102180753.png" alt="图片"></p> <h3 id="判断材质域">判断材质域</h3> <p><strong><em>复制一个输入节点来判断材质域</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102170922.png" alt="图片"> <strong><em>打组，修改输入输出，Domain是整形，输出Value是布尔</em></strong> <strong><em>0.5~1.5是Face</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102172025.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102172135.png" alt="图片"> <strong><em>同理创建3个判断</em></strong> <strong><em>1.5~2.5是Eye</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102172510.png" alt="图片"> <strong><em>大于2.5是Body</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102173034.png" alt="图片"> <strong><em>完成后</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102173349.png" alt="图片"></p> <h2 id="对eye材质域进行alpha混合">对Eye材质域进行alpha混合</h2> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250102180727.png" alt="图片"></p> <h2 id="复制当前基础材质">复制当前基础材质</h2> <p><strong><em>给每个材质球都复制一份，并更改材质域和贴图</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102202518.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102202658.png" alt="图片"></p> <h2 id="更改色彩空间改为标准">更改色彩空间改为标准</h2> <p><strong><em>修改后就没那么灰了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102202826.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250102202846.png" alt="图片"></p> <h1 id="添加描边">添加描边</h1> <h2 id="新增描边材质">新增描边材质</h2> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250106195943.png" alt="图片"> <strong><em>先随便给个黑色</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106200452.png" alt="图片"> <strong><em>开启背面剔除</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106200339.png" alt="图片"> <strong><em>复制几个材质给面部身体</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106200751.png" alt="图片"></p> <h3 id="添加实体化">添加实体化</h3> <p><strong><em>这些调整实际上就是把实体化参数全部归零</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106201229.png" alt="图片"></p> <h3 id="添加新的顶点组">添加新的顶点组</h3> <p><strong><em>添加新顶点组，表示生成的新顶点</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106201412.png" alt="图片"> <strong><em>指定给实体化修改器，这样就得到实体化生成的一个顶点组</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106201539.png" alt="图片"> <strong><em>添加几何节点</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106201724.png" alt="图片"> <strong><em>几何节点，取出刚才的组里的点</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106202606.png" alt="图片"> <strong><em>在添加一个描边材质的组</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106202444.png" alt="图片"> <strong><em>编辑模式下根据材质，选择脸的部分，然后再顶点组里面标记权重为1</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106202847.png" alt="图片"> <strong><em>同理，头发和饰品权重标记为0.7，记得点指定</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106203037.png" alt="图片"> <strong><em>然后衣服选中，标记为0.3</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250303110738.png" alt="图片"></p> <h3 id="几何节点">几何节点</h3> <p><strong><em>提取OutlineMask数据</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106203753.png" alt="图片"> <strong><em>与实体化生成的顶点数据进行比较</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106204147.png" alt="图片"> <strong><em>添加组输入</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106204102.png" alt="图片"> <strong><em>修改类型</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106204234.png" alt="图片"> <strong><em>此时修改器面板需要指定材质</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106204344.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106204419.png" alt="图片"> <strong><em>根据权重数据，设置不同材质</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106205247.png" alt="图片"> <strong><em>添加描边宽度参数</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106205530.png" alt="图片"> <strong><em>设置描边法线外扩</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106205655.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106210058.png" alt="图片"> <strong><em>输出</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106210931.png" alt="图片"> <strong><em>此时描边还是断开的，需要读取平滑法线进行修复</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106210901.png" alt="图片"> <strong><em>可以使用按距离合并，能用，但会有瑕疵，使用UV中的平滑数据就不会这样，当前这里是偷懒的办法</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106211531.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106211517.png" alt="图片"></p> <h3 id="加入相机深度">加入相机深度</h3> <p><strong><em>添加相机并设置FOV</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107165837.png" alt="图片"> <strong><em>几何节点计算相机到物体深度</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107214159.png" alt="图片"> <strong><em>这里注意一点，ViewDir在这里和Unity中不太一样，这里是相机指向物体，而Unity和UE都是处理成物体指向相机，本质其实差不多，只是计算CameraForward就需要取Vector（0,0,1,1）</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107215551.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107214705.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107214122.png" alt="图片"> <strong><em>计算ViewDir</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107171522.png" alt="图片"> <strong><em>对于Blender的相机面向的是负Z轴方向，所以取Vector（0,0,-1,1）进行偏转获得CameraForward向量</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107213730.png" alt="图片"> <strong><em>ViewDir和CameraForward进行dot获取深度，也就是相机和物体距离在CameraForward方向上的投影长度，这样可以规避旋转的影响，计算ViewDir在CameraForWard方向上的投影，然后钳制到0~1</em></strong> <strong><em>UE单位是CM所以是钳制到100，而Blender是M所以是钳制到1，1m内随屏幕占比缩小或放大，描边适当放大或缩小不至于消失或过粗，1m外就随屏幕占比而缩小</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107215759.png" alt="图片"> <strong><em>接入描边粗细控制，这里乘上45是FOV的值，因为在相机中物体做了透视投影，这里希望与FOV进行关联</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107223117.png" alt="图片"></p> <h3 id="加入顶点描线z偏移">加入顶点描线Z偏移</h3> <p><strong><em>新增参数</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107223441.png" alt="图片"> <strong><em>这里获取偏移方向</em></strong> <strong><em>顶点位置在裁剪空间下Z偏移等价于世界空间下延视线方向偏移</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107224150.png" alt="图片"> <strong><em>进行归一化得到偏移方向的单位向量，然后乘上ZOffset的值就是偏移量</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107224233.png" alt="图片"> <strong><em>因为只有面部需要偏移，所以需要混合设置，在这里获取混合因子</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107224523.png" alt="图片"> <strong><em>然后与原输出法线外扩的数据进行相加就行了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107224653.png" alt="图片"> <strong><em>此时还是有瑕疵，转动视角描边有问题</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107224857.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107224831.png" alt="图片"></p> <h3 id="描边问题修复">描边问题修复</h3> <p><strong><em>描边问题出在，几何节点中的Position是模型空间下的，而相机位置是世界空间下的，这里注意，虽然说相机位置显示的坐标是和世界坐标一致，但它其实是观察坐标系</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250107225155.png" alt="图片"></p> <h4 id="世界变换">世界变换</h4> <p><strong><em>在旧的版本中，ObjectInfo是没有Transform选项的，所以需要手动计算变换，进行矩阵变换</em></strong> <strong><em>这里先处理点位置，这里是属于仿射变换，包括平移，旋转，缩放</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250108182533.png" alt="图片"> <strong><em>手动转换，这里先对位置进行处理相减，然后反向旋转，最后处理缩放</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109180637.png" alt="图片"> <strong><em>新版Blender可以使用转换矩阵进行转换</em></strong> <strong><em>这里直接获得物体空间到世界空间的逆矩阵，这样就获得了物体空间矩阵，将相机位置转换到物体空间，就和Position同一空间了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109180958.png" alt="图片"> <strong><em>除了将相机位置转换到物体空间，也可以反过来，将Position转换到世界空间</em></strong> <strong><em>取世界空间矩阵进行空间变换，获得世界空间下的顶点位置PositionWS，这样也可以计算，但这里需要注意，转换后的PositionWS和CameraPos还是不是同一坐标系，还是需要对CameraPos进行处理</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109181419.png" alt="图片"> <strong><em>这里将原位置改为相对位置就可以了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109181844.png" alt="图片"> <strong><em>最后还有就是对于向量的变换，属于线性变换，我们只需要处理旋转和缩放就行</em></strong> <strong><em>这里是选择全部转换到物体空间，因为步骤较为简单</em></strong> <strong><em>取出旋转的逆</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109182257.png" alt="图片"> <strong><em>这里对CameraForWard向量进行变换，转换到物体空间</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109182355.png" alt="图片"></p> <h4 id="除开变换额外的问题">除开变换额外的问题</h4> <p><strong><em>到这里描边修复基本完成，但依旧还存在问题，那就是仅在相机视角观察是对的，因为这里取的是活动相机位置</em></strong> <strong><em>当前是相机里面观察</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109182707.png" alt="图片"> <strong><em>这里是不用相机</em></strong> <strong><em>转动视角，描边出现问题，这里不修其实也无伤大雅，因为渲染仅在相机中渲染，是不会影响最终输出的，如何想要预览正常，在新版中也可以修改</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109182754.png" alt="图片"></p> <h4 id="调整描边生成方式修复预览">调整描边生成方式修复预览</h4> <p><strong><em>断开几何节点输出，创建StoreNamedAttrbute存储属性进行输出，将Name设置为Outline,Value设置为1</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109184510.png" alt="图片"> <strong><em>找到描边的材质，在里面进行处理，读取刚才几何节点传出的属性</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109184943.png" alt="图片"> <strong><em>计算深度并打组</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109185414.png" alt="图片"> <strong><em>添加参数，描边宽度</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109185615.png" alt="图片"> <strong><em>获取描边外扩</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109191249.png" alt="图片"> <strong><em>计算ZOffset，这里需要将相机位置转换到世界空间</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109190046.png" alt="图片"> <strong><em>混合输出</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109191306.png" alt="图片"> <strong><em>修改组名称并输出</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109190624.png" alt="图片"> <strong><em>这里输出后还是没有效果，需要调整材质面板设置</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109191329.png" alt="图片"> <strong><em>这时面部描边就生效了，先把节点组复制所有的描边材质</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109192001.png" alt="图片"> <strong><em>最终预览，注意除了面部，其他部位不需要ZOffset</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109192333.png" alt="图片"></p> <h4 id="两种生成方式">两种生成方式</h4> <p><strong><em>几何节点是CPU计算，而在Shader中有GPU加速所以会渲染快很多，看帧率都看的出来，而且Shader里面是没有瑕疵的</em></strong></p> <h3 id="描边颜色混合">描边颜色混合</h3> <h4 id="导入贴图">导入贴图</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250109193241.png" alt="图片"> <strong><em>这里设置采样颜色模式为无SRGB</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109193208.png" alt="图片"> <strong><em>DataTex打组</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109202103.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109193528.png" alt="图片"> <strong><em>创建描边自发光Shader，这里进行区域判断和颜色混合</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109203157.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109203128.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109202219.png" alt="图片"> <strong><em>解码DataTex判断是否是Body部分，只有Body部分是分了很多材质，描边颜色不一样</em></strong> <strong><em>如果是Face部分，就输出ID=0,进使用Color1进行设置颜色</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109202921.png" alt="图片"> <strong><em>计算材质ID,这里第一个乘应该是x5不是4</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109202417.png" alt="图片"> <strong><em>如果材质域是Body，会进行混合颜色</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109202910.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109202856.png" alt="图片"> <strong><em>将输出颜色压暗</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109203018.png" alt="图片"></p> <h4 id="描边完整节点">描边完整节点</h4> <p><strong><em>注意要调一下材质域，衣服部分使用是OtherDataTex的Color2输入，除了面部模型的OutlineShader组的Color1是粉色FF8181，其余都是灰色555555</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109203838.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109203828.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250109203857.png" alt="图片"></p> <h3 id="最终描边效果">最终描边效果</h3> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250109203701.png" alt="图片"></p> <h2 id="为什么使用实体化修改器而不是直接几何节点合并操作">为什么使用实体化修改器而不是直接几何节点合并操作</h2> <p><strong><em>如果合并的话，原模型的自定义法线会被修改，这里进行合并</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106212413.png" alt="图片"> <strong><em>合并前</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106220644.png" alt="图片"> <strong><em>合并后</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106220618.png" alt="图片"> <strong><em>使用实体化来进行描边的权重注册，这里指定了顶点组，是为了让实体化出来的顶点进行注册权重，可以理解为是取原来模型的那一部分顶点进行实体化，并修改权重</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106222913.png" alt="图片"> <strong><em>在几何节点中判断权重，这样取的实体化修改器法线外扩的顶点信息</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250106222854.png" alt="图片"></p> <h1 id="着色阶段">着色阶段</h1> <h2 id="添加平行光">添加平行光</h2> <p><strong><em>调整一下角度，我这里是45度</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111191315.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111191435.png" alt="图片"></p> <h2 id="几何节点中将光数据传给shader">几何节点中将光数据传给Shader</h2> <h3 id="平行光向量lightdirws">平行光向量LightDirWS</h3> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250111193032.png" alt="图片"></p> <h3 id="平行光颜色">平行光颜色</h3> <p><strong><em>创建合并颜色节点</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111193324.png" alt="图片"> <strong><em>平行光的颜色需要使用驱动器进行读取</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111193412.png" alt="图片"> <strong><em>调整类型</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111193450.png" alt="图片"> <strong><em>指定场景的灯光，获取颜色</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111193526.png" alt="图片"> <strong><em>其他几个通道同理，这里还需要乘上光照强度</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111194046.png" alt="图片"> <strong><em>驱动器设置</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111194110.png" alt="图片"> <strong><em>输出平行光颜色</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111195116.png" alt="图片"></p> <h2 id="构建基础光照模型">构建基础光照模型</h2> <h3 id="读取灯光数据进行打组">读取灯光数据进行打组</h3> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250111195457.png" alt="图片"> <strong><em>打组，修改变量名称</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111195659.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111195642.png" alt="图片"></p> <h3 id="读取法线和漫反射偏移">读取法线和漫反射偏移</h3> <p><strong><em>加入贴图，这里贴图RG是法线，B是漫反射偏移</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111195906.png" alt="图片"></p> <h4 id="创建lighttex组">创建LightTex组</h4> <p><strong><em>添加贴图，调整颜色格式</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111200432.png" alt="图片"> <strong><em>打组</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111200857.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111200847.png" alt="图片"></p> <h4 id="为基础shader组添加参数">为基础Shader组添加参数</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250111201520.png" alt="图片"></p> <h4 id="解析lighttex">解析LightTex</h4> <p><strong><em>这里直接进行打组创建</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111201715.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111210130.png" alt="图片"> <strong><em>先进行重映射，采样后映射到-1~1</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111210234.png" alt="图片"> <strong><em>进行法线强度控制</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111210427.png" alt="图片"> <strong><em>因为法线的各个向量平方之和是1，由此可以计算出Z分量，这里因为浮点数计算误差和贴图误差等，为了保证X和Y的平方和不超过1使用了Min节点</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111213834.png" alt="图片"> <strong><em>进行合并给到法线贴图节点，这里需要注意，这里不能使用Normalize归一化，因为Blender的NormalMap节点会进行Normal的重映射进行(x2-1),而之前计算的时候已经映射过了（-1~1），所以需要重新映射回来，就是(x0.5+0.5)重新回到0-1范围</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111214731.png" alt="图片"></p> <p><strong><em>只有身体部分有法线贴图和漫反射偏移，所以进行判断非身体部分直接输出普通法线，上方是漫反射偏移，乘上了系数2，下方是法线输出</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111215315.png" alt="图片"></p> <h4 id="计算baseattenuation衰减lambert">计算BaseAttenuation衰减（Lambert）</h4> <p><strong><em>解析了法线和漫反射偏移，就可以计算兰伯特光照了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111215611.png" alt="图片"> <strong><em>BaseAttenuation内部节点</em></strong> <strong><em>用PiexlNorma点乘光线向量然后加上漫反射偏移DiffuseBais</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111215703.png" alt="图片"></p> <h3 id="输出测试">输出测试</h3> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250111215838.png" alt="图片"> <strong><em>给各个材质进行分别设置Light贴图</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111215907.png" alt="图片"> <strong><em>光照效果</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250111215938.png" alt="图片"></p> <h2 id="光照分层着色">光照分层着色</h2> <h3 id="forwardshader新增输入">ForWardShader新增输入</h3> <p><strong><em>添加软硬控制，光滑系数</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250121222946.png" alt="图片"></p> <h3 id="创建新组">创建新组</h3> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250121223307.png" alt="图片"></p> <h4 id="对albedosmoothness处理">对AlbedoSmoothness处理</h4> <p><strong><em>先乘上1.5倍进行重映射，1-重映射的值获取锐利系数，锐利系数 = 1 - 光滑系数</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250121224413.png" alt="图片"></p> <h4 id="添加baseattenuation并进行重映射">添加BaseAttenuation并进行重映射</h4> <p><strong><em>新增组输入</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250121224246.png" alt="图片"></p> <h3 id="分层">分层</h3> <h3 id="分层公式">分层公式</h3> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250115183100.png" alt="图片"> <strong><em>对应代码，S1为锐利系数，S0为光滑系数</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250117222413.png" alt="图片"> <strong><em>这里是分为7层：</em></strong> ShadowFade最深阴影 Shadow较浅阴影 ShallowFade中间过渡较深阴影 Shallow中间过渡较浅阴影 SSS次表面部分 Front 明亮区域，接近没有衰减 Forward 最强反射部分,没有衰减</p> <h4 id="shadowfade最深阴影">ShadowFade最深阴影</h4> <p><strong><em>除以锐利系数</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250121225039.png" alt="图片"></p> <h4 id="shadow较浅阴影">Shadow较浅阴影</h4> <p><strong><em>除以光滑系数</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250121230147.png" alt="图片"></p> <h4 id="shallowfade中间过渡较深阴影">ShallowFade中间过渡较深阴影</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250121230518.png" alt="图片"></p> <h4 id="shallow中间过渡较浅阴影">Shallow中间过渡较浅阴影</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250121230547.png" alt="图片"></p> <h4 id="sss次表面部分">SSS次表面部分</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250121230611.png" alt="图片"></p> <h4 id="front-明亮区域接近没有衰减">Front 明亮区域，接近没有衰减</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250121230634.png" alt="图片"></p> <h4 id="forward-最强反射部分没有衰减">Forward 最强反射部分,没有衰减</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250121230654.png" alt="图片"></p> <h4 id="分别输出">分别输出</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250121230742.png" alt="图片"></p> <h3 id="albedo传入参数">Albedo传入参数</h3> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250121230949.png" alt="图片"></p> <h3 id="forward组追加颜色参数输入">Forward组追加颜色参数输入</h3> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250121232044.png" alt="图片"></p> <h3 id="forward组追加datatex输入">Forward组追加DataTex输入</h3> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250122165845.png" alt="图片"></p> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250122165824.png" alt="图片"></p> <h3 id="将albedo组再进行打组处理并添加输入参数">将Albedo组再进行打组处理并添加输入参数</h3> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250122171458.png" alt="图片"></p> <h3 id="对各分层进行颜色混合">对各分层进行颜色混合</h3> <h4 id="阴影颜色根基深度进行提亮">阴影颜色根基深度进行提亮</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250122172123.png" alt="图片"> <strong><em>打组</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250122172300.png" alt="图片"> <strong><em>在进行打组创建NormalizeByAverageColor组，对颜色进行归一化，效果上，因为平均颜色的值小于1，这里会对颜色进行提亮</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250122172804.png" alt="图片"> <strong><em>打组，对深度和颜色进行混合，这里乘上0.43725，表示在0.43725m内时颜色会增亮，而相机远离时，变成原本的亮度</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250122173405.png" alt="图片"> <strong><em>添加参数，对shadowColor和ShallowColor进行划分成两个亮度，对应就是ShadowFade和Shadow，ShallowFade和Shallow，然后进行输出</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250122174244.png" alt="图片"> <strong><em>对ShallowFadeTint、ShallowTint设置默认值</em></strong> PostShadowTint： CDCDCDFF PostShadowFadeTint： CDCDCDFF PostShallowTint： E6E6E6 PostShallowFadeTint： E6E6E6 <strong><em>对于非阴影部分，不需要进行颜色亮度调整，直接输入输出即可，新增输入输出</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250122175122.png" alt="图片"> <strong><em>默认值调整</em></strong> PostSssTint： FFF1E6 PostFrontTint：FFFFFF PostForwardTint：FFFFFF <strong><em>返回上层，当前节点为</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250122175509.png" alt="图片"></p> <h4 id="混合各层颜色">混合各层颜色</h4> <p><strong><em>乘法进行混合颜色后，将阴影部分进行相加，这里需要乘上灯光的颜色，所以现在对灯光进行处理</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250122175913.png" alt="图片"> <strong><em>追加灯光颜色输入</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250122180150.png" alt="图片"></p> <p><strong><em>阴影部分混合的灯光颜色需要压暗，这里是对灯光颜色处理，处理过后直接进行乘法混合</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250122180401.png" alt="图片"> <strong><em>阴影部分混合处理后的灯光颜色</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250122180459.png" alt="图片"> <strong><em>非阴影部分直接进行混合即可</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250122180542.png" alt="图片"></p> <h4 id="传入参数">传入参数</h4> <p><strong><em>返回上层对ShadowColor和ShallowColor以及灯光颜色进行传入</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250122181007.png" alt="图片"> <strong><em>最上层节点调整，AlbedoSmoothness默认为0.1，设置传入DataTex</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250122181622.png" alt="图片"> <strong><em>暴露阴影颜色值给外部，方便调整</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250124174733.png" alt="图片"> <strong><em>暂时保持默认值就行</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250124174757.png" alt="图片"></p> <h4 id="颜色参数设置">颜色参数设置</h4> <p><strong><em>面部</em></strong> ShadowColor1 ：DDBFBF ShallowColor1 ：EEDDDD <strong><em>头发，饰品</em></strong> ShallowColor1 ：EEDDDD ShallowColor2 ：A7A3B9 ShallowColor3 ：DAE3E8 ShallowColor4 ：E6BEBD ShallowColor5 ：E6D4DF</p> <p>ShadowColor1 : DDBFBF ShadowColor2 : 66637B ShadowColor3 : ABB4CE ShadowColor4 : B48B8C ShadowColor5 : CCACBA <strong><em>服装</em></strong> ShallowColor1 ：B9BFD1 ShallowColor2 ：DFE8ED ShallowColor3 ：E6CEBF ShallowColor4 ：9C94BC ShallowColor5 ：93A0B2</p> <p>ShadowColor1 : 8685AB ShadowColor2 : BAC3E0 ShadowColor3 : CCA586 ShadowColor4 : 8780AG ShadowColor5 : 637082 <strong><em>面部参数调整</em></strong> ShadowColor1 ：DDBFBF ShallowColor1 ：EEDDDD</p> <h4 id="当前预览">当前预览</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250124183443.png" alt="图片"> <strong><em>乘上基础颜色</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250304170857.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250124183819.png" alt="图片"></p> <h2 id="投影追加gooengine">投影追加GooEngine</h2> <p><strong><em>一般的Blender版本只能在后期处理中获取深度图，但这里需要再材质面板中获取，只有GooEngine版本才行，但是GooEngine的描边只能使用几何节点构造，材质面板没有置换选项</em></strong> <strong><em>一般版本获取深度：找到层设置，开启passes选项中的Z</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250302193410.png" alt="图片"> <strong><em>合成面板这里就有了Depth节点了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250302193429.png" alt="图片"></p> <h3 id="灯光向量转换到观察空间">灯光向量转换到观察空间</h3> <p><strong><em>光向量转换到观察空间得到偏移方向，因为是做屏幕投影，那么只要XY的方向信息即可，所以乘上（1,1，0）</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250304212707.png" alt="图片"></p> <h3 id="计算偏移量">计算偏移量</h3> <p><strong><em>这里乘上5是经验值，除以100应该是以百分制来控制偏移强度</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250304222513.png" alt="图片"></p> <h3 id="计算采样的屏幕深度uv">计算采样的屏幕深度UV</h3> <p><strong><em>GooEngine特有的节点，这里可以看到输入是观察空间下的Position。</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250304222757.png" alt="图片"> <strong><em>那么基于原UV进行偏移就可以得到新的UV,将当前位置转换到观察空间进行相加即可。注意这里不需要要进行透视除法，ScreenspaceInfo内部应该做了这一步，在Unity和UE中采用深度缓冲都要做透视除法</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310151036.png" alt="图片"></p> <h3 id="采样深度缓冲获得投影">采样深度缓冲获得投影</h3> <p><strong>**将偏移后的UV采样获得新的深度，新深度减去原深度即可获得投影，这里为了防止自投影所以原深度需要减去一个较小阈值，可以理解为去除面部，鼻子的阴影所做的处理，后面乘上一个应该是经验值的50，在使用FadeOut参数控制衰减程度，最后Clamp钳制到0~1</strong>* <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310151109.png" alt="图片"> <strong><em>输出测试可以看到投影正常生成了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310151301.png" alt="图片"></p> <h3 id="将shadowattenuation融入之前的分段">将ShadowAttenuation融入之前的分段</h3> <p><strong><em>对应代码操作</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250305123826.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250305123249.png" alt="图片"> <strong><em>重映射为两个分段</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250305123658.png" alt="图片"></p> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250305124310.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250305124334.png" alt="图片"></p> <h3 id="投影混合后的效果">投影混合后的效果</h3> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250305123154.png" alt="图片"></p> <h2 id="sdf面部阴影">SDF面部阴影</h2> <h3 id="创建定位点">创建定位点</h3> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250306171309.png" alt="图片"> <strong><em>绑定到骨骼</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250306171350.png" alt="图片"> <strong><em>找到头部的骨骼名称进行指定</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250306171430.png" alt="图片"> <strong><em>对每个定位点指定父级骨骼</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250306171534.png" alt="图片"> <strong><em>调整位置，定位点移到骨骼根部，记得开启吸附</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250306172218.png" alt="图片"> <strong><em>HeadCenter延法线进行移动0.05到骨骼中心</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250306172353.png" alt="图片"> <strong><em>HeadRight除了向上移动0.05，还需要向人物面部的右侧移动0.05</em></strong> <strong><em>HeadForward除了向上移动0.05，还需要向人物面部的前方移动0.05</em></strong> <strong><em>位置如下</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250306173019.png" alt="图片"></p> <h3 id="创建贴图组">创建贴图组</h3> <p><strong><em>对于面部的SDF图读取，因为要根据灯光信息来决定采样UV的U方向，所以这里直接输出两个，一个的正常一个U反向</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307123327.png" alt="图片"></p> <h3 id="面部材质读取特殊处理">面部材质读取特殊处理</h3> <p><strong><em>因为面部是特殊的LightMap而且没有材质ID,所以LightMap的位置是空的，刚好这里可以利用起来，直接用空出的槽位读取</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307123802.png" alt="图片"></p> <h3 id="创建解析light的组">创建解析Light的组</h3> <p><strong><em>因为只有面部使用所以需要区域判断，还有灯光向量也需要输入</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307124058.png" alt="图片"></p> <h4 id="计算灯光在面部的投影">计算灯光在面部的投影</h4> <p><strong><em>这里解释一下project节点就相当于AB向量点乘得到的B在A上的投影距离再乘上A,在用光向量减去这个投影向量就可以得到面到光源的一个向量</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307124832.png" alt="图片"></p> <h4 id="计算光向量与面部的夹角">计算光向量与面部的夹角</h4> <p><strong><em>A为面部到光源的向量，B和C为A在面部的前方向的负向量和右向量上面的投影长度，这里可以想象BC构成一个水平的坐标系，A是照射上面是斜着的，根据三角函数可以求出Tangent正切，在通过反正切函数得到角度</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307200159.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307191746.png" alt="图片"> <strong><em>注意这里不是常规的反正切而是actan2函数，对应上图的话就是左右分两半，从-Forward方向为起点也就是0，向下为末端π，左半为正右半为负。所以函数的输出范围就是-π到π，那么转为弧度就-1到1。如果大于0就1-去这个值，小于零就加1，这样就得到当光线在正面时为0，在背面为1</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307200324.png" alt="图片"></p> <h4 id="根据光源方向翻转uv方向">根据光源方向翻转UV方向</h4> <p><strong><em>光源投影向量与右向量点乘，大于0就表示在右侧需要翻转UV的U反向采样，反之则不需要。因为贴图是默认是光线在左</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250306163120.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307213634.png" alt="图片"></p> <h4 id="根据区域来控制是否使用">根据区域来控制是否使用</h4> <p><strong><em>分通道输出，仅在材质域为面部的时候输出，反之输出0即可</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307213950.png" alt="图片"> <strong><em>到这里解析贴图数据节点完成</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307214115.png" alt="图片"></p> <h3 id="混合之前的着色层级">混合之前的着色层级</h3> <p><strong><em>找到AlbedoShader添加输入</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307214308.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250306222607.png" alt="图片"></p> <h4 id="sdf分层">SDF分层</h4> <p><strong><em>看节点费劲可以看这个代码去连</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250305211639.png" alt="图片"> <strong><em>在AlbedoShader内部创建新组进行数据处理</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307214456.png" alt="图片"> <strong><em>内部处理节点</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307215146.png" alt="图片"> <strong><em>计算angleAttenuation,这里计算方式应该是设计好的，具体怎么设计的不清楚，现在就已经成功得到SDF了，但还需要对投影进行混合</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307215253.png" alt="图片"> <strong><em>分层</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307215412.png" alt="图片"> <strong><em>混合输出，这里算法太复杂，我也不清楚为什么这样计算</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307215501.png" alt="图片"> <strong><em>最后在将输出和BaseAttenuation进行混合，使用AngelMask作为混合因子</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250307215754.png" alt="图片"></p> <h4 id="当前效果">当前效果</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250307220041.png" alt="图片"></p> <h2 id="添加鼻线">添加鼻线</h2> <p><strong><em>当前没有鼻线，灯光在正面没有鼻子很奇怪</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310231833.png" alt="图片"></p> <h3 id="读取鼻线mask">读取鼻线Mask</h3> <p><strong><em>鼻线的位置其实是在面部贴图的Alpha通道中，我们已经进行传入了，但是没有调用</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310232411.png" alt="图片"></p> <h3 id="创建noseline组">创建NoseLine组</h3> <h4 id="参数设置">参数设置</h4> <p><strong><em>先为Forward组添加输入参数，垂直水平显示的阈值还有鼻线颜色</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310232547.png" alt="图片"> <strong><em>创建新组并设置输入等参数</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310233102.png" alt="图片"> <strong><em>传入的Mask需要先判断是否为Face</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310233149.png" alt="图片"></p> <h4 id="获取观察向量">获取观察向量</h4> <p><strong><em>获取观察向量一般来说是对世界空间下相机向量进行归一化即可。但Blender不太一样，它的相机深度轴不是Z,而是-Z,所以需要翻转。当然也有简单的获取方法** **</em>方法一</strong>* <strong><em>直接从几何属性获取，Incoming就是ViewDirWS，说实话这名字真不太熟啊。。</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310233515.png" alt="图片"> <strong><em>方法二</em></strong> <strong><em>直接计算</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310234448.png" alt="图片"></p> <h4 id="计算鼻线的displayvalue">计算鼻线的DisplayValue</h4> <p><strong><em>参考代码</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310111654.png" alt="图片"> <strong><em>根据点乘判断方向&gt;0同向，小于0反向，计算ViewDir和HeadUP点积已及ViewDir和HeadRight点积用作判断。</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310234521.png" alt="图片"> <strong><em>这里我们需要自己写一个SmoothStep节点，因为Blender是MapRange节点里的不符合我们需要</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310234819.png" alt="图片"> <strong><em>Smooth公式及节点如下：</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310230304.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310235001.png" alt="图片"> <strong><em>计算完成后输出结果，颜色进行压暗处理</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310235107.png" alt="图片"></p> <h3 id="混合输出">混合输出</h3> <p><strong><em>先使用NoseLineDispValue混合描边颜色和基础颜色</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310235202.png" alt="图片"> <strong><em>混合完成后再使用Face的布尔值对带描线的颜色和不带描线的颜色混合</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310235417.png" alt="图片"></p> <h3 id="参数设置-1">参数设置</h3> <p><strong><em>给ForwardShader调参数，颜色为FF8181</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250310235506.png" alt="图片"></p> <h3 id="当前效果-1">当前效果</h3> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250310235646.png" alt="图片"></p> <h2 id="添加matcap">添加MatCap</h2> <h3 id="贴图打组">贴图打组</h3> <p><strong><em>MatCap的遮罩信息在下方贴图的B通道中，先打组传入ForwardShader等下处理</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314172045.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314171851.png" alt="图片"></p> <h3 id="计算matcap的uv">计算MatCap的UV</h3> <p><strong><em>因为Blender的组中不能传入贴图采样器，所以只能在ForwardShader组外面对matcap处理</em></strong> <strong><em>使用之前的两个组获取法线</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314172318.png" alt="图片"> <strong><em>创建一个新的组进行MatCapUV的计算</em></strong> <strong><em>采样matCap的固定公式，将法线转换到观察空间，取XY作为UV进行采样，这里因为原本法线是-1~1，这里需要重映射到0~1，这样得到了基础的MatcapUV</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314172450.png" alt="图片"> <strong><em>添加输入参数</em></strong> <strong><em>对应的折射开关，折射深度，折射UV的缩放和平移</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314172702.png" alt="图片"> <strong><em>在Unity或者UE中可以用4维的向量控制缩放和平移，但是Blender的向量属性只显示3维，所以这里只能拆分掉缩放和平移参数使用两个向量控制</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314173004.png" alt="图片"> <strong><em>当折射开启时，需要对UV进行调整，当然这里并非是真的计算折射，其实只是对MatCap采样进行缩放和平移调整。这里先乘上折射深度</em></strong> <strong><em>整体公式就是：matCapUV = matCapUV * depth + Scale * input.uv + Offset;</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314173130.png" alt="图片"></p> <p><strong><em>计算并加上物体本身UV方向的平移值</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314173345.png" alt="图片"> <strong><em>最后在加上整体的平移</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314173511.png" alt="图片"> <strong><em>最后根据折射开关的Bool进行输出不同的UV,不开启就输出基础的MatCapUV</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314173549.png" alt="图片"></p> <h3 id="forwardshader计算">ForwardShader计算</h3> <h4 id="参数添加">参数添加</h4> <p><strong><em>添加参数，对应是MatCap开关，MatCap贴图，Matcap染色，Matcap颜色强度和Alpha强度以及混合模式</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314173938.png" alt="图片"></p> <h4 id="处理matcap相关参数">处理Matcap相关参数</h4> <p><strong><em>获取材质ID</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314175445.png" alt="图片"> <strong><em>根据材质ID控制输出颜色等数据，之前只写了颜色选择，这里记得需要新建和修改，拓展两个出来，一个是Float类型，一个是Int类型</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314175529.png" alt="图片"> <strong><em>读取传入的贴图新建一个组进行解释获得MatCap的Mask</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314175739.png" alt="图片"> <strong><em>取出B通道就是MatCap的Mask</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314175842.png" alt="图片"></p> <h3 id="混合计算matcap">混合计算MatCap</h3> <p><strong><em>参数都处理完后，新建应该混合的组进行颜色混合</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314180016.png" alt="图片"> <strong><em>输入参数</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314180119.png" alt="图片"> <strong><em>这里分为三种混合模式</em></strong> <strong><em>混合模式参数对应，0：乘法混合，1：加法混合，2：叠加混合</em></strong> <strong><em>乘法混合（Multiply Alpha Blend）</em></strong> <strong><em>这里先计算Alpha的值，blendColor就是MatCap采样颜色乘上基础混合颜色和Matcap颜色总强度，最后是使用alpha进行插值</em></strong> <strong><em>从效果来说，乘法会使颜色变暗，而使用alpha混合，输出部分就全部是Matcap颜色或全是基础颜色，两者是不会有重叠的</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314180151.png" alt="图片"> <strong><em>加法混合（Additive Blend）</em></strong> <strong><em>同样先计算Alpha，几个混合模式中Alpha是一样的。这里是先是使用乘法混合matcap颜色和相关系数，最后是加法混合，使用原本颜色加上matcap颜色</em></strong> <strong><em>效果来说就，在最后一步加法混合时，原颜色并没有剔除掉Alpha中部分，所以在alpha区域两个颜色相加就会变亮</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314180211.png" alt="图片"> <strong><em>叠加混合（Overlay Blend）</em></strong> <strong><em>叠加混合之前做了增加对比度的操作</em></strong> <strong><em>对比度调整</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250312224202.png" alt="图片"> <strong><em>先对matcap的blendColor进行处理，-0.5就是原本颜色范围变成-0.5~0.5以0.5为中心环绕，这时这个值作为一个基数在乘上颜色强度就得到了一个降低暗部增强亮部的系数，最后加上原本的matcapColor,相当于以matcapColor增强对比度</em></strong> <strong><em>为了防止前面的颜色对比度过高失真所以使用一个中性灰色0.5进行平滑</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314180236.png" alt="图片"></p> <p><strong><em>最终混合输出，使用MatCap开关判断是否使用MatCap</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314182503.png" alt="图片"></p> <h3 id="最外层参数调整">最外层参数调整</h3> <p><strong><em>饰品，头发等</em></strong> <strong><em>MatCapTintColor5：E0C8BF</em></strong> <strong><em>第五个插槽是丝袜的Matcap，需要开启折射，调整RefractUVScale5为0</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314182622.png" alt="图片"> <strong><em>服装</em></strong> <strong><em>颜色MatCapTintColor2：DBE4F8，MatCapTintColor5：D9E6EC</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250314182729.png" alt="图片"></p> <h3 id="当前效果-2">当前效果</h3> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250314182834.png" alt="图片"></p> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250314182903.png" alt="图片"></p> <h2 id="颜色锐化处理">颜色锐化处理</h2> <h3 id="创建gammacolor组">创建GammaColor组</h3> <h4 id="参数设置-2">参数设置</h4> <p><strong><em>输入输出参数</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315233029.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315233117.png" alt="图片"></p> <h4 id="计算遮蔽信息">计算遮蔽信息</h4> <p><strong><em>NDotL，顶点法线的兰伯特非常光滑细节较少</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315230058.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315225911.png" alt="图片"> <strong><em>pixelNDotL，含贴图法线发兰伯特拥有很多细节</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315230119.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315225948.png" alt="图片"> <strong><em>NDotL - pixelNDotL，两者相减可以得到物体的凹凸信息，那么用1减去这个值就可以得到一个遮罩的遮蔽信息occlusion</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315230140.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315230027.png" alt="图片"></p> <p><strong><em>当前遮蔽信息还是不够强烈所以先乘上3在用1减去，这样增强效果，这里乘以几都可以，可以随意调整，以效果为主,最后进行钳制防止有小于零的值</em></strong> <strong><em>saturate((1 - 3 * (NDotL - pixelNDotL)))</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315231304.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315231321.png" alt="图片"> <strong><em>occlusion的杂色太多了，所以整体提亮2倍，去除一些杂色，只保留较小的信息，这里乘几同样也是经验值类的，自己随意调整以效果为准</em></strong> <strong><em>(saturate((1 - 3 * (NDotL - pixelNDotL))) * 2</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315231411.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315231422.png" alt="图片"> <strong><em>最后计算获得一个颜色衰减值，兰伯特的值是-1~1，这里使用半兰伯特0~1和遮罩系数进行计算是为了保留教暗地方的依旧有颜色衰减值，我们默认使用的是兰伯特光照，所以这里进行混合，使用0.5也就是均匀混合。这样就得到了一个颜色的衰减值，注意这里说的衰减值是作用于Gamma矫正也就是颜色变化，而不是仅仅亮度变化，这里叫做颜色Gamma矫正衰减系数应该比较合适</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315231533.png" alt="图片"></p> <h4 id="计算颜色亮度和gamma值">计算颜色亮度和gamma值</h4> <p><strong><em>有了颜色Gamma矫正衰减系数，然后知道Gamma矫正的值后，就可以对颜色进行Gamma矫正了，但在这之前需要钳制颜色亮度，因为Gamma其实本质可以理解为Pow(Color，gamma)，对于大于1的进行Pow会导致变得非常亮</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315231806.png" alt="图片"> <strong><em>ClampColor组</em></strong> <strong><em>这里对颜色各个分量取得最大值，如果大于1，就将整个颜色除以这个值进行压暗，保证颜色不变的情况下降低明度，钳制到1以下** <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315231917.png" alt="图片"> **</em>Luminance组</strong>* <strong><em>这里计算颜色的亮度值，因为Blender没有Luminance函数所以需要我们自己创建，参数有两个，一个是颜色，一个是各个通道的权重值，公式： 亮度值 = 0.299×R+0.587×G+0.114×B</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315232122.png" alt="图片"> <strong><em>使用颜色Gamma矫正衰减系数混合计算Gmma值，这里这个乘 0.2875和加1.4375的操作也属于经验值，并不是固定的，以效果为准。有了Gama值后，现在就进行颜色的Gamma矫正了。Blender直接使用Gamma节点，根据效果来调整强度，使用兰伯特控制，亮的部分就使用Gamma，暗的地方就减小Gamma强度使用GammaHalf</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315232602.png" alt="图片"> <strong><em>完整节点</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315234803.png" alt="图片"></p> <h4 id="颜色混合输出">颜色混合输出</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250315233456.png" alt="图片"></p> <h3 id="当前效果-3">当前效果</h3> <p><strong><em>左边是无处理，右边是进行颜色调整了的</em></strong> <strong><em>可以看出处理过之后颜色变化更明显了，没有那么扁平了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250315233555.png" alt="图片"></p> <h2 id="添加pbr高光">添加PBR高光</h2> <h3 id="贴图信息">贴图信息</h3> <p><strong><em>找到找到DataTex1贴图组，其中G通道就是金属度，B通道是高光遮罩</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319134741.png" alt="图片"> <strong><em>金属度</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319134812.png" alt="图片"> <strong><em>高光遮罩</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319134957.png" alt="图片"></p> <p><strong><em>找到DataTex2组，光滑度信息在G通道中</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319135037.png" alt="图片"> <strong><em>光滑度</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319135330.png" alt="图片"></p> <h3 id="提取贴图信息">提取贴图信息</h3> <h4 id="金属和高光遮罩">金属和高光遮罩</h4> <p><strong><em>修改之前解释DataTex1的组，提取金属和高光遮罩信息</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319212522.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319212546.png" alt="图片"></p> <h4 id="光滑度">光滑度</h4> <p><strong><em>修改之前解释DataTex2的组，提取光滑度信息</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319212627.png" alt="图片"> <strong><em>这里注意默认给0.58的光滑度而不是0</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319212650.png" alt="图片"></p> <h3 id="pbr漫反射和高光划分">PBR漫反射和高光划分</h3> <h4 id="划分比例">划分比例</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250316145231.png" alt="图片"></p> <h4 id="创建dividepbrcolor新组">创建DividePBRColor新组</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250319212801.png" alt="图片"> <strong><em>pbrDiffuseColor进行金属与非金属的划分，非金属的最大漫反射比例是0.96，0.96 x Color就是非金属的漫反射，而金属部分是只有镜面反射的没有漫反射，所以漫反射为0。pbrSpecularColor镜面反射，非金属的镜面反射比例就是1-0.96，因为非金属的镜面反射颜色不受本身颜色影响仅受材料的反射率影响，所以这里给上0.04固定颜色。而金属部分，金属的镜面反射是受颜色影响的所以反射原本的颜色</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319145325.png" alt="图片"></p> <h3 id="高光的一般计算方法">高光的一般计算方法</h3> <p><strong><em>高光的常规计算方式是Phong和BlinnPhong</em></strong></p> <h4 id="phong-brdf">Phong BRDF</h4> <p><strong><em>公式：</em></strong> <strong><em>K是指SpecularIntensity高光强度，R是灯光向量（-L）的反射向量，V是观察向量，这里需要指明一点这里参加计算的灯光向量是物体指向灯光的向量，也就是-L</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250317140026.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250317141340.png" alt="图片"> <strong><em>常规计算代码：</em></strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre><span class="n">float3</span> <span class="n">reflect_dir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">light_dir</span><span class="p">,</span> <span class="n">normal_dir</span><span class="p">);</span> <span class="c1">//获取灯光反射向量</span>
<span class="kt">float</span> <span class="n">RdotV</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">reflect_dir</span><span class="p">,</span> <span class="n">view_dir</span><span class="p">);</span><span class="c1">//数值范围在-1~1所以需要限制</span>
<span class="n">float3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">RdotV</span><span class="p">),</span> <span class="n">_Shininess</span><span class="p">)</span> <span class="o">*</span> <span class="n">_SpecularIntensity</span><span class="p">;</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="blinn-phong-brdf">Blinn-Phong BRDF</h4> <p><strong><em>K是指SpecularIntensity高光强度，H是半角向量是L和V之间的向量，V是观察向量,它不需要计算反射所以性能被Phong更好</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250317141812.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250317141851.png" alt="图片"></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre><span class="n">half3</span> <span class="n">half_dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light_dir</span> <span class="o">+</span> <span class="n">view_dir</span><span class="p">);</span><span class="c1">//获得灯光与视角中间的半角向量</span>
<span class="n">half</span> <span class="n">NdotH</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">normal_dir</span><span class="p">,</span> <span class="n">half_dir</span><span class="p">);</span><span class="c1">///数值范围在-1~1所以需要限制</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="pbr中-ggx-brdf高光计算">PBR中 GGX BRDF高光计算</h4> <p><strong><em>相关资料</em></strong> <a href="https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/siggraph2015_2D00_mmg_2D00_renaldas_2D00_notes.pdf" rel="external nofollow noopener" target="_blank">https://community.arm.com/cfs-file/__key/communityserver-blogs-components-weblogfiles/00-00-00-20-66/siggraph2015_2D00_mmg_2D00_renaldas_2D00_notes.pdf</a> <strong><em>公式：</em></strong> <strong><em>公式看起来太复杂了，说人话就是D是像NoH粗糙度影响然后乘上SpecularMask得到高光形状（这部分可以由我们自己调整），F是菲涅尔系数，G是物体表面的遮蔽。F和G是固定公式</em></strong> <strong><em>GGX高光计算</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250317151131.png" alt="图片"> <strong><em>不乘上面末尾的NoL就是BRDF计算的结果</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250317145043.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250317150032.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250317150839.png" alt="图片"></p> <p><strong><em>Unity中URP的BRDF.hlsl文件中也有介绍,但这里是使用的优化版的减少计算量</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250317144917.png" alt="图片"> <strong><em>简化方式简单来说就是将F(菲涅尔项)与G(几何遮蔽项)变成了V点乘F</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250317151101.png" alt="图片"> <strong><em>将含G的这部分式子替换成V了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250317151351.png" alt="图片"> <strong><em>不需要纠结怎么简化的，反正最后优化成近似的结果，V乘F公式就变成了下面这个,L是光向量，H是半角向量</em></strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
</pre></td> <td class="rouge-code"><pre><span class="n">V</span> <span class="o">*</span> <span class="n">F</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="p">(</span> <span class="n">LoH</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">roughness</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong><em>计算公式就变成了</em></strong></p> <pre><code class="language-C">BRDFspec = (D * V * F) / 4.0

Finalspec = (D * V * F) / 4.0 * NoL
</code></pre> <h3 id="forward组输入参数增加">Forward组输入参数增加</h3> <p><strong><em>分别对应金属度，光滑度，头部球形法线范围，总高光强度，球形法线高光开关，高光范围，高光软硬度控制，高光Toon强度，根基模型大小控制高光强度的额外控制</em></strong></p> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250319212400.png" alt="图片"> <strong><em>高光染色</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319150044.png" alt="图片"></p> <h3 id="饰品类pbr卡通高光计算">饰品类PBR卡通高光计算</h3> <h4 id="参数处理">参数处理</h4> <p><strong><em>使用MatID和Select组处理输入</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319212836.png" alt="图片"></p> <h4 id="创建高光shader组">创建高光Shader组</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250319212856.png" alt="图片"></p> <h4 id="计算halfdir和传入参数">计算HalfDir和传入参数</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250319213107.png" alt="图片"> <strong><em>传入对应参数</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319213157.png" alt="图片"></p> <h4 id="计算球形法线使用范围">计算球形法线使用范围</h4> <p><strong><em>Specular内</em></strong> <strong><em>头发部分使用球形法线，其余部分使用贴图法线，使用顶点位置减去球心HeadCenter位置就可以得到球状法线，使用HeadSphereRang进行控制范围计算出球形法线的一个遮罩，使用遮罩对贴图法线和球形法线混合输出</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319154457.png" alt="图片"></p> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250319153852.png" alt="图片"></p> <h4 id="使用球状遮罩混合法线">使用球状遮罩混合法线</h4> <p><strong><em>当HeadSphereRang有效时输出混合的法线，无效则输出贴图法线</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319213400.png" alt="图片"></p> <h4 id="计算高光项和衰减项">计算高光项和衰减项</h4> <p><strong><em>根据公式，计算高光项ShapeNoH。当HeadSphereRang计算ShapeAttenuation，反之使用原贴图法线计算的BaseAttenuation</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319213703.png" alt="图片"> <strong><em>使用混合法线计算的衰减进行了开方和重映射都是为了调整曲线，增加高光的有效范围，开放可以使高光的衰减变平缓</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250317154915.png" alt="图片"></p> <h4 id="最终计算">最终计算</h4> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td> <td class="rouge-code"><pre><span class="n">V</span> <span class="o">*</span> <span class="n">F</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="p">(</span> <span class="n">LoH</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">roughness</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span>
<span class="n">Finalspec</span> <span class="o">=</span> <span class="p">(</span><span class="n">D</span> <span class="o">*</span> <span class="n">V</span> <span class="o">*</span> <span class="n">F</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span> <span class="o">*</span> <span class="n">NoL</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <p><strong><em>回忆公式，这里VxF项中Roughness直接给1，然后直接使用公式计算</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319214722.png" alt="图片"> <strong><em>计算完(D * V * F) / 4.0后和RangeNoL相乘就得到高光了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319214820.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319220309.png" alt="图片"></p> <h3 id="衣服类pbr写实高光计算">衣服类PBR写实高光计算</h3> <p><strong><em>这里直接照抄GGX就行</em></strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr>
<td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td> <td class="rouge-code"><pre><span class="err"> </span><span class="n">brdfData</span><span class="p">.</span><span class="n">normalizationTerm</span> <span class="o">=</span> <span class="p">(</span><span class="n">roughness</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span>
<span class="err"> </span>
<span class="err"> </span><span class="n">Final</span> <span class="n">BRDFspec</span> <span class="o">=</span> <span class="n">roughness</span><span class="o">^</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span> <span class="n">NoH</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">roughness</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">LoH</span><span class="o">^</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">roughness</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
</pre></td> </tr></tbody></table></code></pre></div></div> <h4 id="光滑度转粗糙度等参数处理">光滑度转粗糙度等参数处理</h4> <p><strong><em>这里还是使用GGX的计算方式，但需要引入粗糙度计算了，贴图给的是光滑度，需要进行处理，这里直接新建一个处理光滑度的组</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319215102.png" alt="图片"> <strong><em>这里计算Roughness的相关参数。光滑度转粗糙度是1-Smoothness在平方，1-Smoothness是感知粗糙度，真正参与计算的是它的平方，也就是粗糙度</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319215636.png" alt="图片"></p> <h4 id="计算ggx">计算GGX</h4> <p><strong><em>根据公式直接计算GGX高光，这里直接使用贴图法线计算</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319215819.png" alt="图片"></p> <h4 id="最终混合">最终混合</h4> <p><strong><em>计算完GGX后减去光滑度，降低光滑表面的高光强度，然后乘上光照衰减，钳制到0~1。除以粗糙度这里在提高粗糙表面的高光强度。最后使用两个参数控制高光强度然后乘上高光遮罩后就得到了高光，末尾的乘法相当于提高了高光的硬度</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319220115.png" alt="图片"></p> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250319220223.png" alt="图片"></p> <h3 id="两种高光混合">两种高光混合</h3> <p><strong><em>使用是否开启了球形法线为判断来混合，后面使用SpecularIntensity进行整体的强度控制，然后染色</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319220622.png" alt="图片"></p> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250319220600.png" alt="图片"></p> <h3 id="混合颜色-1">混合颜色</h3> <p><strong><em>使用区域判断，因为高光在面部眼睛是没有的，所以使用身体开关判断</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319221250.png" alt="图片"> <strong><em>使用乘法进行计算，最后混合Diffuse和Specular直接加法混合即可</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319221541.png" alt="图片"></p> <h3 id="当前效果-4">当前效果</h3> <p><strong><em>参数</em></strong> <strong><em>默认总强度是0.01，头发需要开启球形法线高光，其余参数自己看着调就行</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319221739.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250319221647.png" alt="图片"></p> <h2 id="添加环境光">添加环境光</h2> <h3 id="球谐光照计算公式">球谐光照计算公式</h3> <p><a href="https://zhuanlan.zhihu.com/p/351289217" rel="external nofollow noopener" target="_blank">https://zhuanlan.zhihu.com/p/351289217</a></p> <h3 id="获取环境光">获取环境光</h3> <p><strong><em>UE和Unity中都是使用球谐光照来作为环境光，Blender中这里直接使用漫反射节点获取</em></strong> <strong><em>Forward组新增强度控制参数</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250321164200.png" alt="图片"> <strong><em>这里需要对灯光进行调整，将漫反射和高光影响都设置为0，这样就只有环境光了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250321162848.png" alt="图片"> <strong><em>调整天空球可以看到颜色变化，但是平行光移动和旋转不会影响</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250321164424.png" alt="图片"></p> <h3 id="环境光混和">环境光混和</h3> <p><strong><em>得到环境光后转换成RGB颜色与强度控制参数相乘，然后在和GammaColor进行乘法混合</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250321164616.png" alt="图片"> <strong><em>输出直接使用加法混合即可，加上漫反射和高光。因为亮度会增加可能导致高光效果不明显，所以这里将高光部分大于1的部分在加一遍对高光提亮</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250321164736.png" alt="图片"></p> <h3 id="当前效果-5">当前效果</h3> <p><strong><em>左边是加了环境光，右面是没加的</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250321170054.png" alt="图片"></p> <h2 id="添加边缘光">添加边缘光</h2> <h3 id="forwardshader新增参数">ForwardShader新增参数</h3> <p><strong><em>对应是皮肤ID,屏幕空间边缘光宽度、阈值、衰减强度、亮度，太阳光光颜色，边缘光染色</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327140731.png" alt="图片"></p> <h3 id="创建边缘光shader">创建边缘光Shader</h3> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250327141318.png" alt="图片"></p> <h3 id="输入参数处理">输入参数处理</h3> <p><strong><em>法线，灯光向量和ShadowAttenuation以及屏幕空间参数</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327141422.png" alt="图片"> <strong><em>IsSkin计算和金属度</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327141517.png" alt="图片"> <strong><em>PBR参数直接拉过来就行</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327141650.png" alt="图片"> <strong><em>阳光颜色以及边缘光染色和之前操作一样，使用MatID进行判断输出</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327141029.png" alt="图片"></p> <h3 id="相关参数计算">相关参数计算</h3> <h4 id="背光衰减">背光衰减</h4> <p><strong><em>因为边缘光是根据视线方向和灯光方向来控制的，比如说背光的时候边缘光会很强，而面光面就比较弱。所以先计算LOV</em></strong> <strong><em>这里对（-LOV）进行了重映射，映射到0~1，这里注意是（-LOV)，因为LOV根据点乘特征同向为一反向为-1，所以面光面为1，背光面为-1，而边缘光应该以背光面为主，所以取（-LOV）计算，得到viewAttenuation</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327141855.png" alt="图片"> <strong><em>这里得到viewAttenuation后还做了额外的处理，先进行平方后在乘0.5和加0.5，相当于平滑过渡，同时也是为了面光面也有边缘光为0.5，不为0，下面的函数图可以更好理解</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250324230706.png" alt="图片"></p> <h4 id="法线垂直方向衰减">法线垂直方向衰减</h4> <p><strong><em>UE是Z轴向上，所以这里取法线的Z方向，也就是垂直的方向，重映射到0~1。对皮肤和服装部分进行区分，让服装的强度低一点直接进行平方，最后整体进行平滑处理</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327142036.png" alt="图片"></p> <h4 id="兰伯特方向衰减">兰伯特方向衰减</h4> <p><strong><em>其实就光源对于模型的衰减，也适用于边缘光。这里因为之前计算过投影，所以也追加进去</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327142133.png" alt="图片"></p> <h4 id="菲涅尔衰减">菲涅尔衰减</h4> <p><strong><em>这一步是真正求边缘光的步骤，一般边缘光都是通过菲涅尔进行计算。因为这里需要对相机距离进行反馈，所以先计算相机距离，这里相机距离有现成的节点直接用</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327142337.png" alt="图片"> <strong><em>对皮肤进行判断，皮肤的菲涅尔效果应该比衣服更弱，所以被（1-NOV)减去的值应该更多，然后衰减程度也和相机距离相关，min(1, cameraDistance / 12.0)最大值为1，当相机距离为12米时为最大，这里12.0就是相机距离，综合起来看就是随距离越远，菲涅尔强度略微增强（其实肉眼看不太出来）</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327142322.png" alt="图片"></p> <h4 id="相机距离衰减">相机距离衰减</h4> <p><strong><em>这里相当于5m之后开始逐渐衰减，5m之前不变，因为小于5的时候减去的部分是负数进行钳制就会变成0</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327142418.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250325012211.png" alt="图片"></p> <h4 id="背光外围向中心方向衰减">背光外围向中心方向衰减</h4> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250327142453.png" alt="图片"></p> <h3 id="边缘光颜色控制">边缘光颜色控制</h3> <h4 id="阳光颜色混色">阳光颜色混色</h4> <p><strong><em>皮肤只混合灰度，而非皮肤混合颜色。这里对阳光强度控制，先对基础颜色进行压制将颜色尽量压制到暗部，然后进行不完全的归一化，对暗处提亮，而亮的地方进行压制防止过曝，前面进行压制过后暗处的地方相当于变多了，那么暗部细节就会提亮。这里其实是计算平均整体亮度，但是为了保证有一定明暗关系，所以取了0.7而不是1</em></strong> <strong><em>最后混合，人物的投影和边缘都受阳光颜色影响染色，其余的则由Albedo负责</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327142643.png" alt="图片"></p> <h4 id="边缘光漫反射和镜面反射">边缘光漫反射和镜面反射</h4> <p><strong><em>上面边缘光使用提亮过后的漫反射颜色，先提亮在使用平均值进行压暗等处理，下面使用BRDiffuseColor的强度计算得到边缘光的强度</em></strong> <strong><em>边缘光的镜面反射直接使用PBR镜面反射，使用金属度划分插值边缘光漫反射和镜面反射程度然后整体控制强度，然后乘上上面计算的衰减参数和光源颜色以及边缘光染色就得到边缘光了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327142919.png" alt="图片"></p> <h4 id="衰减混合">衰减混合</h4> <p><strong><em>将计算的相关衰减都乘起来就得到了基础的边缘光了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327143633.png" alt="图片"> <strong><em>这里基础强度乘了个48</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327143806.png" alt="图片"> <strong><em>在末尾乘上边缘光的染色，这里的颜色强度也做了控制。</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327143857.png" alt="图片"> <strong><em>大致曲线是这样，略微平滑提亮</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250325105925.png" alt="图片"> <strong><em>现在边缘光大致就是这样的，为了看着更清楚我又提亮了50倍（不用跟着操作）</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327144350.png" alt="图片"></p> <h3 id="屏幕空间边缘光">屏幕空间边缘光</h3> <p><strong><em>得到菲涅尔计算得到的边缘光内部有非常多细节，而屏幕空间计算的边缘没有那么多内部细节所以可以剔除这些不必要的细节</em></strong> <strong><em>之前提过Blender屏幕空间采样只有GooEngine版本有对应节点，而普通版只有在后期处理做，会比较麻烦</em></strong></p> <h4 id="gooengine方法">GooEngine方法</h4> <p><strong><em>这里和计算投影是一个原理，但是使用的法线方向偏移，而Blender这里法线需要重映射，因为读取出来的范围是-1~1。采样偏移的深度图与原深度图进行相减。计算最后就是乘上一个强度系数控制</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327143510.png" alt="图片"> <strong><em>这里自己调参数</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327145610.png" alt="图片"></p> <h4 id="普通版方法">普通版方法</h4> <p><strong><em>需要获取深度Z和法线，但这里层级里面的是世界空间的法线，我们需要屏幕空间法线，而后期处理里面不能转换，所以需要自己在材质中处理</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327145814.png" alt="图片"> <strong><em>材质中转换之后使用AOV输出</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327150226.png" alt="图片"> <strong><em>层级面版中需要声明，名字保持一致</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327150312.png" alt="图片"></p> <p><strong><em>现在后期里面就有这个输出了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327150412.png" alt="图片"> <strong><em>计算方法和GooEngine是一样的，但是有些差异</em></strong> <strong><em>后期里面的归一化只有1维的，所以归一化只能自己手动写。归一化就是向量各个分量除以向量的模</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327150657.png" alt="图片"> <strong><em>法线直接对XY向量归一化就行了，因为不需要第三个分量计算</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327151009.png" alt="图片"> <strong><em>各分量乘上宽度在进行透视除法除以深度（GooEngine计算不需要透视除法），最后合并成向量就得到了偏移量了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327151357.png" alt="图片"> <strong><em>剩下就是计算深度差值了，后期里面是直接使用置换节点控制</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327153621.png" alt="图片"> <strong><em>差不多就这样子，参数自己随便调。</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327153837.png" alt="图片"></p> <h3 id="最终混合-1">最终混合</h3> <p><strong><em>两种高光直接乘法混合输出，普通版Blender就需要将菲涅尔计算的高光AOV输出到后期进行混合</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327153927.png" alt="图片"> <strong><em>最外层输出边缘光直接加法加上去就行</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327154112.png" alt="图片"></p> <h3 id="当前效果-6">当前效果</h3> <p><strong><em>有一点点效果就行了，参数自己随便调，我这的GooEngine参数是下面这个，颜色随便给灰度就行</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327154330.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250327154232.png" alt="图片"></p> <h2 id="眼睛处理">眼睛处理</h2> <h3 id="参数调整">参数调整</h3> <p><strong><em>调整眼影和内外高光的透明度，眼影改成黑色</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250330235841.png" alt="图片"> <strong><em>修改混合模式为Alpha混合</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250330235933.png" alt="图片"> <strong><em>调整形态键可以看到外高光在眼影下面，这里需要调整顺序</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331000011.png" alt="图片"> <strong><em>Blender是直接使用材质插槽进行排序，将外高光顺序调到眼影下方</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331000048.png" alt="图片"> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331000147.png" alt="图片"></p> <h3 id="眼透处理">眼透处理</h3> <p><strong><em>Unity中使用模板测试，UE有两张深度图，Blender里面这两个都没有，GooEngine版仅有一张深度图，所以这里做眼透只能采用后期处理来做了</em></strong></p> <h4 id="拆分网格">拆分网格</h4> <p><strong><em>将前发和眼睛部分拆出来，记得清理材质</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331001202.png" alt="图片"> <strong><em>创建两个集合，将眼睛和头发分别放进去</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331001454.png" alt="图片"> <strong><em>将遮罩显示打开</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331001550.png" alt="图片"></p> <h4 id="视图层渲染设置">视图层渲染设置</h4> <p><strong><em>复制视图层</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331001824.png" alt="图片"> <strong><em>直接复制设置</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331001927.png" alt="图片"> <strong><em>重命名，当前就有了眼睛视图层</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331002024.png" alt="图片"> <strong><em>打开身体部分的遮挡，只做遮挡使用</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331002102.png" alt="图片"> <strong><em>禁用头发</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331002202.png" alt="图片"></p> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250331002222.png" alt="图片"> <strong><em>给视图层添加AOV输入，将眼睛遮罩传入后期处理</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331002328.png" alt="图片"> <strong><em>切回到原视图，将头发遮罩传入</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331002535.png" alt="图片"> <strong><em>头发材质中将1 - Alpha传入后期</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331002753.png" alt="图片"> <strong><em>眼睛部分的所有材质，传1就行，这里注意眼睛模型材质插槽中所有材质中都要有这一步。</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331003018.png" alt="图片"></p> <h3 id="后期处理">后期处理</h3> <h4 id="关于半透明aov传值问题">关于半透明AOV传值问题</h4> <p><strong><em>上面对于眼睛数据传入AOV数据，这里需要额外的修改** **</em>Blender中半透明材质是不能给后期处理传值的，也就不能输出AOV。这里指的半透明是指混合模式为AlphaBlend。</strong>* <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331015608.png" alt="图片"> <strong><em>当然混合模式不止一种，这里仅当AlphaHashed模式和不透明模式下可以传递AOV。AlphaBlend和AlphaHashed计算方式不同，后者开销更大，但是它可以传递AOV，一般用于树叶，毛发一类需要正确排序的情况。正常使用就用AlphaBlend了</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331015705.png" alt="图片"> <strong><em>所以这里有几个处理方法</em></strong> <strong><em>1.眼睛整体不传值，直接使用当前遮罩</em></strong> <strong><em>2.眼睛部分是不透明，只需要传眼睛材质的就行</em></strong> <strong><em>3.将除了眼睛部分的高光眼影的混合模式改为AlphaHashed，在分别传值</em></strong></p> <h4 id="混合两个视图层">混合两个视图层</h4> <p><strong><em>我这里使用的是直接传眼睛部分，高光不管，方法3开销很多，本来就已经很卡了</em></strong> <strong><em>这里取得头发和眼睛的遮罩进行钳制然后相乘就可以得到需要叠加眼透的遮罩，在用这个遮罩混合两个图层</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331020808.png" alt="图片"> <strong><em>对应的头发，眼睛，以及眼透的遮罩</em></strong> <img src="/assets/img/ZZZRendering/Pasted%20image%2020250331021144.png" alt="图片"></p> <h2 id="最终效果">最终效果</h2> <p><img src="/assets/img/ZZZRendering/Pasted%20image%2020250331021254.png" alt="图片"></p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/Lv.2-Unity%E4%B8%BB%E7%BA%BF-%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%85%89/">Lv.2 Unity主线：添加环境光</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/Lv.2-Unity%E4%B8%BB%E7%BA%BF-%E6%B7%BB%E5%8A%A0%E5%A4%9A%E5%85%89%E6%BA%90%E4%BA%A4%E4%BA%92/">Lv.2 Unity主线：添加多光源交互</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/Lv.2-Unity%E4%B8%BB%E7%BA%BF-%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8BPhong%E5%92%8CBlinn-Phong/">镜面反射光照模型Phong和Blinn-Phong</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/Lv.2-Unity%E4%B8%BB%E7%BA%BF-%E6%B7%BB%E5%8A%A0%E6%B3%95%E7%BA%BF/">Lv.2 Unity主线：添加法线</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/Lv.2-Unity%E4%B8%BB%E7%BA%BF-%E6%B7%BB%E5%8A%A0%E9%98%B4%E5%BD%B1/">Lv.2 Unity主线： 添加阴影</a> </li> </div> # # <script>
# (function() {
#   'use strict';
  
#   document.addEventListener('DOMContentLoaded', function() {
#     // 检查 Medium Zoom 是否可用
#     if (typeof mediumZoom !== 'undefined') {
#       // 使用 Medium Zoom
#       mediumZoom('.post-content img:not([width]):not([style])', {
#         margin: 24,
#         background: 'rgba(0, 0, 0, 0.9)',
#         scrollOffset: 0
#       });
#       console.log('Medium Zoom enabled');
#     } else {
#       // 如果没有 Medium Zoom，手动添加点击事件
#       const images = document.querySelectorAll('.post-content img:not([width]):not([style])');
#       images.forEach(function(img) {
#         img.style.cursor = 'zoom-in';
#         img.addEventListener('click', function() {
#           // 简单的全屏显示
#           const overlay = document.createElement('div');
#           overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.9);z-index:9999;display:flex;align-items:center;justify-content:center;cursor:zoom-out;';
          
#           const enlargedImg = document.createElement('img');
#           enlargedImg.src = this.src;
#           enlargedImg.style.cssText = 'max-width:90%;max-height:90%;object-fit:contain;';
          
#           overlay.appendChild(enlargedImg);
#           document.body.appendChild(overlay);
          
#           overlay.addEventListener('click', function() {
#             document.body.removeChild(overlay);
#           });
#         });
#       });
#       console.log('Manual zoom enabled for', images.length, 'images');
#     }
#   });
# })();
# </script> <script>
(function() {
  'use strict';
  
  document.addEventListener('DOMContentLoaded', function() {
    
    
    const selector = '.post-content img:not([width]):not([style]):not([data-spotlight-converted])';
    const images = document.querySelectorAll(selector);
    
    if (images.length === 0) {
      console.log('Spotlight: No images to convert');
      return;
    }
    
    images.forEach(function(img) {
      if (img.parentElement.classList.contains('spotlight')) {
        return;
      }
      
      const link = document.createElement('a');
      link.className = 'spotlight';
      link.href = img.src;
      
      if (img.alt) {
        link.setAttribute('data-description', img.alt);
      }
      
      img.setAttribute('data-spotlight-converted', 'true');
      
      // 强制设置样式（防止被覆盖）
      img.style.cssText = 'max-width: 75% !important; display: block !important; margin: 1em auto !important; cursor: zoom-in !important;';
      
      const parent = img.parentNode;
      parent.insertBefore(link, img);
      link.appendChild(img);
    });
    
    console.log('Spotlight: Converted', images.length, 'images');
    
    
  });
})();
</script> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 吟处雪 轻遮. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" target="_blank" rel="external nofollow noopener">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/spotlight.js@0.7.8/dist/spotlight.bundle.min.js" crossorigin="anonymous"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>