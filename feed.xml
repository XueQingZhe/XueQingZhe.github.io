<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://xueqingzhe.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://xueqingzhe.github.io/" rel="alternate" type="text/html" hreflang="zh-CN"/><updated>2025-12-23T15:08:52+00:00</updated><id>https://xueqingzhe.github.io/feed.xml</id><title type="html">blank</title><subtitle>Technical Artist specializing in real-time rendering, toon shading, and PBR techniques. </subtitle><entry><title type="html">Lv.1 Unity主线：Built-in Shader结构速览</title><link href="https://xueqingzhe.github.io/blog/2025/Lv.1-Unity%E4%B8%BB%E7%BA%BF-Built-in-Shader%E7%BB%93%E6%9E%84%E9%80%9F%E8%A7%88/" rel="alternate" type="text/html" title="Lv.1 Unity主线：Built-in Shader结构速览"/><published>2025-12-21T00:00:00+00:00</published><updated>2025-12-21T00:00:00+00:00</updated><id>https://xueqingzhe.github.io/blog/2025/Lv.1%20Unity%E4%B8%BB%E7%BA%BF%EF%BC%9ABuilt-in%20Shader%E7%BB%93%E6%9E%84%E9%80%9F%E8%A7%88</id><content type="html" xml:base="https://xueqingzhe.github.io/blog/2025/Lv.1-Unity%E4%B8%BB%E7%BA%BF-Built-in-Shader%E7%BB%93%E6%9E%84%E9%80%9F%E8%A7%88/"><![CDATA[<h1 id="基本结构">基本结构</h1> <p><img src="/assets/img/TAMonth01/Pasted image 20251203164844.png" alt="图片"/></p> <h1 id="subshader-tags">SubShader Tags</h1> <h2 id="render-type">Render Type</h2> <p><img src="/assets/img/TAMonth01/Pasted image 20251203170938.png" alt="图片"/></p> <h2 id="queue">Queue</h2> <p><img src="/assets/img/TAMonth01/Pasted image 20251203171204.png" alt="图片"/></p> <h2 id="lod">LOD</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="n">SubShader</span>
<span class="p">{</span>
    <span class="n">LOD</span> <span class="mi">300</span>  <span class="c1">// ← 这就是LOD关键字</span>
    <span class="n">Pass</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="c1">// C#代码中设置 Shader.globalMaximumLOD = 200;</span>
<span class="c1">// 只使用LOD&lt;=200的SubShader </span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>选择规则：</strong> 如果设置 Shader.globalMaximumLOD = 200 SubShader LOD 300 ← 跳过（超过限制） SubShader LOD 200 ← ✅ 使用这个 SubShader LOD 100 ← 不会用到（因为已经找到合适的）</p> <p>Unity内置Shader的LOD标准</p> <h3 id="unity官方推荐的lod值">Unity官方推荐的LOD值</h3> <p>| LOD值 | 质量等级 | 示例Shader | | —- | —- | ——————————- | | 600+ | 最高质量 | 物理基础渲染 + 曲面细分 | | 500 | 非常高 | VertexLit + 所有像素光 | | 300 | 高 | Diffuse + Specular + Normal Map | | 200 | 中 | Diffuse + Specular | | 150 | 中低 | Diffuse + 简化光照 | | 100 | 低 | Vertex Lit（顶点光照） | | 50 | 最低 | 无光照 | <strong>Unity内置Shader的LOD值：</strong></p> <p>Standard Shader = 300 Bumped Specular = 300 Bumped Diffuse = 200 Diffuse = 200 Specular = 200 VertexLit = 100 Unlit = 100</p> <h2 id="ignoreprojector">IgnoreProjector</h2> <p><strong>忽略投影</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">Tags</span> <span class="p">{</span> <span class="s">"IgnoreProjector"</span><span class="o">=</span><span class="s">"True"</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><img src="/assets/img/TAMonth01/Pasted image 20251203171336.png" alt="图片"/></p> <h2 id="forcenoshadowcasting">ForceNoShadowCasting</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">Tags</span> <span class="p">{</span> <span class="s">"ForceNoShadowCasting"</span><span class="o">=</span><span class="s">"True"</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><img src="/assets/img/TAMonth01/Pasted image 20251203171503.png" alt="图片"/></p> <h2 id="disablebatching">DisableBatching</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">Tags</span> <span class="p">{</span> <span class="s">"DisableBatching"</span><span class="o">=</span><span class="s">"True"</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><img src="/assets/img/TAMonth01/Pasted image 20251203171712.png" alt="图片"/></p> <h2 id="previewtype">PreviewType</h2> <p><strong><em>细节面板预览形状</em></strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">Tags</span> <span class="p">{</span> <span class="s">"PreviewType"</span><span class="o">=</span><span class="s">"Plane"</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><img src="/assets/img/TAMonth01/Pasted image 20251203172058.png" alt="图片"/></p> <h2 id="canusespriteatlas">CanUseSpriteAtlas</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">Tags</span> <span class="p">{</span> <span class="s">"CanUseSpriteAtlas"</span><span class="o">=</span><span class="s">"True"</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><img src="/assets/img/TAMonth01/Pasted image 20251203172147.png" alt="图片"/></p> <h1 id="pass-tags">Pass Tags</h1> <h2 id="lightmode">LightMode</h2> <p><img src="/assets/img/TAMonth01/Pasted image 20251203172447.png" alt="图片"/> <img src="/assets/img/TAMonth01/Pasted image 20251203172705.png" alt="图片"/></p> <h2 id="requireoptions">RequireOptions</h2> <p><img src="/assets/img/TAMonth01/Pasted image 20251203172836.png" alt="图片"/></p> <h2 id="passflags">PassFlags</h2> <p><img src="/assets/img/TAMonth01/Pasted image 20251203173126.png" alt="图片"/></p> <h1 id="pass-keyworld">Pass keyworld</h1> <h2 id="cull">Cull</h2> <p><img src="/assets/img/TAMonth01/Pasted image 20251203173822.png" alt="图片"/> <img src="/assets/img/TAMonth01/Pasted image 20251203174026.png" alt="图片"/></p> <h2 id="ztest">ZTest</h2> <p><img src="/assets/img/TAMonth01/Pasted image 20251203173840.png" alt="图片"/></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre><span class="c1">// 普通物体（默认）</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">ZTest</span> <span class="n">LEqual</span>  <span class="c1">// 近的覆盖远的</span>
<span class="p">}</span>

<span class="c1">// 透视效果（X光）</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">ZTest</span> <span class="n">Greater</span>  <span class="c1">// 只显示被遮挡的部分</span>
    
    <span class="n">CGPROGRAM</span>
    <span class="n">fixed4</span> <span class="n">frag</span><span class="p">()</span> <span class="o">:</span> <span class="n">SV_Target</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">);</span>  <span class="c1">// 半透明红色</span>
    <span class="p">}</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>

<span class="c1">// UI/屏幕空间效果</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">ZTest</span> <span class="n">Always</span>  <span class="c1">// 忽略深度，总是显示</span>
<span class="p">}</span>

<span class="c1">// 描边效果（两个Pass）</span>
<span class="c1">// Pass 1: 正常渲染</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">ZTest</span> <span class="n">LEqual</span>
    <span class="n">CGPROGRAM</span>
    <span class="c1">// 正常渲染</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>

<span class="c1">// Pass 2: 描边</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">ZTest</span> <span class="n">Greater</span>  <span class="c1">// 只渲染被遮挡的部分作为描边</span>
    <span class="n">CGPROGRAM</span>
    <span class="c1">// 放大模型，渲染边缘</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="zwrite">ZWrite</h2> <p><img src="/assets/img/TAMonth01/Pasted image 20251203173855.png" alt="图片"/> <img src="/assets/img/TAMonth01/Pasted image 20251203173944.png" alt="图片"/></p> <h2 id="blend-混合模式">Blend 混合模式</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c1">// 基础语法</span>
<span class="n">Blend</span> <span class="n">SrcFactor</span> <span class="n">DstFactor</span>
<span class="n">Blend</span> <span class="n">SrcFactor</span> <span class="n">DstFactor</span><span class="p">,</span> <span class="n">SrcFactorA</span> <span class="n">DstFactorA</span>  <span class="c1">// 分别控制RGB和Alpha</span>

<span class="c1">// 高级语法</span>
<span class="n">BlendOp</span> <span class="n">Add</span><span class="o">/</span><span class="n">Sub</span><span class="o">/</span><span class="n">RevSub</span><span class="o">/</span><span class="n">Min</span><span class="o">/</span><span class="n">Max</span>  <span class="c1">// 混合操作</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>混合因子：</strong></p> <table> <thead> <tr> <th>因子</th> <th>含义</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">One</code></td> <td>1</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">Zero</code></td> <td>0</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SrcColor</code></td> <td>源颜色</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SrcAlpha</code></td> <td>源Alpha</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">DstColor</code></td> <td>目标颜色</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">DstAlpha</code></td> <td>目标Alpha</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">OneMinusSrcColor</code></td> <td>1 - 源颜色</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">OneMinusSrcAlpha</code></td> <td>1 - 源Alpha</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">OneMinusDstColor</code></td> <td>1 - 目标颜色</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">OneMinusDstAlpha</code></td> <td>1 - 目标Alpha</td> </tr> </tbody> </table> <p><strong>混合公式：</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="err">最终颜色</span> <span class="o">=</span> <span class="p">(</span><span class="err">源颜色</span> <span class="o">*</span> <span class="n">SrcFactor</span><span class="p">)</span> <span class="n">BlendOp</span> <span class="p">(</span><span class="err">目标颜色</span> <span class="o">*</span> <span class="n">DstFactor</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>常用混合模式</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="rouge-code"><pre><span class="c1">// 1. 标准Alpha混合（透明）⭐⭐⭐⭐⭐</span>
<span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">OneMinusSrcAlpha</span>
<span class="c1">// 最终 = 源颜色 * 源Alpha + 目标颜色 * (1 - 源Alpha)</span>

<span class="c1">// 2. 加法混合（发光、粒子）⭐⭐⭐⭐⭐</span>
<span class="n">Blend</span> <span class="n">One</span> <span class="n">One</span>
<span class="c1">// 最终 = 源颜色 + 目标颜色</span>

<span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">One</span>  <span class="c1">// 柔和的加法</span>
<span class="c1">// 最终 = 源颜色 * 源Alpha + 目标颜色</span>

<span class="c1">// 3. 乘法混合（阴影、滤镜）⭐⭐⭐</span>
<span class="n">Blend</span> <span class="n">DstColor</span> <span class="n">Zero</span>
<span class="c1">// 最终 = 目标颜色 * 源颜色</span>

<span class="n">Blend</span> <span class="n">Zero</span> <span class="n">SrcColor</span>  <span class="c1">// 等价写法</span>
<span class="c1">// 最终 = 源颜色 * 目标颜色</span>

<span class="c1">// 4. 正片叠底（Photoshop的Multiply）</span>
<span class="n">Blend</span> <span class="n">DstColor</span> <span class="n">SrcColor</span>
<span class="c1">// 最终 = 源颜色 * 目标颜色 + 目标颜色 * 源颜色</span>

<span class="c1">// 5. 减法混合⭐⭐</span>
<span class="n">BlendOp</span> <span class="n">Sub</span>
<span class="n">Blend</span> <span class="n">One</span> <span class="n">One</span>
<span class="c1">// 最终 = 源颜色 - 目标颜色</span>

<span class="n">BlendOp</span> <span class="n">RevSub</span>
<span class="n">Blend</span> <span class="n">One</span> <span class="n">One</span>
<span class="c1">// 最终 = 目标颜色 - 源颜色</span>

<span class="c1">// 6. 最小值/最大值</span>
<span class="n">BlendOp</span> <span class="n">Min</span>
<span class="n">Blend</span> <span class="n">One</span> <span class="n">One</span>
<span class="c1">// 最终 = min(源颜色, 目标颜色)</span>

<span class="n">BlendOp</span> <span class="n">Max</span>
<span class="n">Blend</span> <span class="n">One</span> <span class="n">One</span>
<span class="c1">// 最终 = max(源颜色, 目标颜色)</span>

<span class="c1">// 7. 预乘Alpha</span>
<span class="n">Blend</span> <span class="n">One</span> <span class="n">OneMinusSrcAlpha</span>
<span class="c1">// 用于已经预乘了Alpha的纹理</span>

<span class="c1">// 8. 柔光（Soft Additive）</span>
<span class="n">Blend</span> <span class="n">OneMinusDstColor</span> <span class="n">One</span>
<span class="c1">// 亮处更亮，暗处影响小</span>

<span class="c1">// 9. 线性减淡（Screen）</span>
<span class="n">Blend</span> <span class="n">OneMinusDstColor</span> <span class="n">One</span>
<span class="n">Blend</span> <span class="n">One</span> <span class="n">OneMinusSrcColor</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>实际应用示例：</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="rouge-code"><pre><span class="c1">// 火焰粒子（加法混合）</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">ZWrite</span> <span class="n">Off</span>
    <span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">One</span>  <span class="c1">// 柔和加法</span>
    
    <span class="n">CGPROGRAM</span>
    <span class="n">fixed4</span> <span class="n">frag</span><span class="p">()</span> <span class="o">:</span> <span class="n">SV_Target</span>
    <span class="p">{</span>
        <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
        <span class="n">col</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*=</span> <span class="n">_TintColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>  <span class="c1">// 增强亮度</span>
        <span class="k">return</span> <span class="n">col</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>

<span class="c1">// 玻璃（标准透明）</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">ZWrite</span> <span class="n">Off</span>
    <span class="n">Blend</span> <span class="n">SrcAlpha</span> <span class="n">OneMinusSrcAlpha</span>
    
    <span class="n">CGPROGRAM</span>
    <span class="n">fixed4</span> <span class="n">frag</span><span class="p">()</span> <span class="o">:</span> <span class="n">SV_Target</span>
    <span class="p">{</span>
        <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
        <span class="n">col</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="p">;</span>  <span class="c1">// 30%透明度</span>
        <span class="k">return</span> <span class="n">col</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>

<span class="c1">// 阴影投射（乘法混合）</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">ZWrite</span> <span class="n">Off</span>
    <span class="n">Blend</span> <span class="n">DstColor</span> <span class="n">Zero</span>  <span class="c1">// 正片叠底</span>
    
    <span class="n">CGPROGRAM</span>
    <span class="n">fixed4</span> <span class="n">frag</span><span class="p">()</span> <span class="o">:</span> <span class="n">SV_Target</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 50%变暗</span>
    <span class="p">}</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="colormask颜色遮罩">ColorMask(颜色遮罩)</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="n">ColorMask</span> <span class="n">RGB</span>   <span class="c1">// 写入RGB（默认）</span>
<span class="n">ColorMask</span> <span class="n">A</span>     <span class="c1">// 只写入Alpha</span>
<span class="n">ColorMask</span> <span class="mi">0</span>     <span class="c1">// 不写入任何颜色</span>
<span class="n">ColorMask</span> <span class="n">RGBA</span>  <span class="c1">// 写入所有通道</span>

<span class="c1">// 组合使用</span>
<span class="n">ColorMask</span> <span class="n">R</span>     <span class="c1">// 只写红色</span>
<span class="n">ColorMask</span> <span class="n">RG</span>    <span class="c1">// 写红色和绿色</span>
<span class="n">ColorMask</span> <span class="n">BA</span>    <span class="c1">// 写蓝色和Alpha</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>应用场景：</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="rouge-code"><pre><span class="c1">// 只写深度，不写颜色（透明物体预处理）</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">ZWrite</span> <span class="n">On</span>
    <span class="n">ColorMask</span> <span class="mi">0</span>  <span class="c1">// 不写任何颜色</span>
<span class="p">}</span>

<span class="c1">// 只写Alpha通道</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">ColorMask</span> <span class="n">A</span>
    <span class="n">CGPROGRAM</span>
    <span class="n">fixed4</span> <span class="n">frag</span><span class="p">()</span> <span class="o">:</span> <span class="n">SV_Target</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_Alpha</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>

<span class="c1">// 模板缓冲配合使用</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">ColorMask</span> <span class="mi">0</span>  <span class="c1">// 不写颜色</span>
    
    <span class="n">Stencil</span>
    <span class="p">{</span>
        <span class="n">Ref</span> <span class="mi">1</span>
        <span class="n">Comp</span> <span class="n">Always</span>
        <span class="n">Pass</span> <span class="n">Replace</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="offset深度偏移">Offset（深度偏移）</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">Offset</span> <span class="n">Factor</span><span class="p">,</span> <span class="n">Units</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>作用：</strong></p> <ul> <li>调整深度值，避免Z-Fighting（深度冲突）</li> <li><code class="language-plaintext highlighter-rouge">Factor</code>：基于多边形斜率的偏移</li> <li><code class="language-plaintext highlighter-rouge">Units</code>：固定单位偏移</li> </ul> <p><strong>应用场景：</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="c1">// 贴花（Decal）</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">Offset</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1">// 向相机方向偏移，避免Z-Fighting</span>
    
    <span class="n">CGPROGRAM</span>
    <span class="c1">// 渲染贴花</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>

<span class="c1">// 描边效果</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">Cull</span> <span class="n">Front</span>
    <span class="n">Offset</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>  <span class="c1">// 向后偏移</span>
    
    <span class="n">CGPROGRAM</span>
    <span class="c1">// 渲染背面作为描边</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="stencil模板缓冲">Stencil（模板缓冲）</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="n">Stencil</span>
<span class="p">{</span>
    <span class="n">Ref</span> <span class="p">[</span><span class="n">_RefValue</span><span class="p">]</span>         <span class="c1">// 参考值（0-255）</span>
    <span class="n">ReadMask</span> <span class="p">[</span><span class="n">_ReadMask</span><span class="p">]</span>    <span class="c1">// 读取遮罩（默认255）</span>
    <span class="n">WriteMask</span> <span class="p">[</span><span class="n">_WriteMask</span><span class="p">]</span>  <span class="c1">// 写入遮罩（默认255）</span>
    
    <span class="n">Comp</span> <span class="p">[</span><span class="n">comparison</span><span class="p">]</span>       <span class="c1">// 比较函数</span>
    <span class="n">Pass</span> <span class="p">[</span><span class="n">stencilOp</span><span class="p">]</span>        <span class="c1">// 测试通过时的操作</span>
    <span class="n">Fail</span> <span class="p">[</span><span class="n">stencilOp</span><span class="p">]</span>        <span class="c1">// 测试失败时的操作</span>
    <span class="n">ZFail</span> <span class="p">[</span><span class="n">stencilOp</span><span class="p">]</span>       <span class="c1">// 深度测试失败时的操作</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>比较函数（Comp）：</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">Never</code> - 永不通过</li> <li><code class="language-plaintext highlighter-rouge">Less</code> - 小于</li> <li><code class="language-plaintext highlighter-rouge">Equal</code> - 等于</li> <li><code class="language-plaintext highlighter-rouge">LEqual</code> - 小于等于</li> <li><code class="language-plaintext highlighter-rouge">Greater</code> - 大于</li> <li><code class="language-plaintext highlighter-rouge">NotEqual</code> - 不等于</li> <li><code class="language-plaintext highlighter-rouge">GEqual</code> - 大于等于</li> <li><code class="language-plaintext highlighter-rouge">Always</code> - 总是通过</li> </ul> <p><strong>操作（Pass/Fail/ZFail）：</strong></p> <ul> <li><code class="language-plaintext highlighter-rouge">Keep</code> - 保持不变</li> <li><code class="language-plaintext highlighter-rouge">Zero</code> - 设为0</li> <li><code class="language-plaintext highlighter-rouge">Replace</code> - 替换为Ref值</li> <li><code class="language-plaintext highlighter-rouge">IncrSat</code> - 加1（饱和，最大255）</li> <li><code class="language-plaintext highlighter-rouge">DecrSat</code> - 减1（饱和，最小0）</li> <li><code class="language-plaintext highlighter-rouge">Invert</code> - 按位取反</li> <li><code class="language-plaintext highlighter-rouge">IncrWrap</code> - 加1（循环）</li> <li><code class="language-plaintext highlighter-rouge">DecrWrap</code> - 减1（循环）</li> </ul> <p><strong>实际应用：遮罩效果</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="rouge-code"><pre><span class="c1">// 示例1：遮罩与被遮罩物体</span>

<span class="c1">// 遮罩物体（写入模板值）</span>
<span class="n">Shader</span> <span class="s">"Custom/StencilMask"</span>
<span class="p">{</span>
    <span class="n">SubShader</span>
    <span class="p">{</span>
        <span class="n">Tags</span> <span class="p">{</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry-1"</span> <span class="p">}</span>  <span class="c1">// 先渲染</span>
        
        <span class="n">Pass</span>
        <span class="p">{</span>
            <span class="n">ZWrite</span> <span class="n">Off</span>
            <span class="n">ColorMask</span> <span class="mi">0</span>  <span class="c1">// 不写颜色</span>
            
            <span class="n">Stencil</span>
            <span class="p">{</span>
                <span class="n">Ref</span> <span class="mi">1</span>
                <span class="n">Comp</span> <span class="n">Always</span>
                <span class="n">Pass</span> <span class="n">Replace</span>  <span class="c1">// 写入模板值1</span>
            <span class="p">}</span>
            
            <span class="n">CGPROGRAM</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>            
            <span class="n">float4</span> <span class="n">frag</span><span class="p">()</span> <span class="o">:</span> <span class="n">SV_Target</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 被遮罩物体（只在遮罩内显示）</span>
<span class="n">Shader</span> <span class="s">"Custom/StencilObject"</span>
<span class="p">{</span>
    <span class="n">SubShader</span>
    <span class="p">{</span>
        <span class="n">Tags</span> <span class="p">{</span> <span class="s">"Queue"</span><span class="o">=</span><span class="s">"Geometry"</span> <span class="p">}</span>
        
        <span class="n">Pass</span>
        <span class="p">{</span>
            <span class="n">Stencil</span>
            <span class="p">{</span>
                <span class="n">Ref</span> <span class="mi">1</span>
                <span class="n">Comp</span> <span class="n">Equal</span>  <span class="c1">// 只在模板值等于1的地方渲染</span>
            <span class="p">}</span>
            
            <span class="n">CGPROGRAM</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>            
            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">()</span> <span class="o">:</span> <span class="n">SV_Target</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>示例2：描边效果</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre><span class="n">SubShader</span>
<span class="p">{</span>
    <span class="c1">// Pass 1: 写入模板</span>
    <span class="n">Pass</span>
    <span class="p">{</span>
        <span class="n">Stencil</span>
        <span class="p">{</span>
            <span class="n">Ref</span> <span class="mi">1</span>
            <span class="n">Comp</span> <span class="n">Always</span>
            <span class="n">Pass</span> <span class="n">Replace</span>
        <span class="p">}</span>
        
        <span class="n">CGPROGRAM</span>
        <span class="c1">// 正常渲染物体</span>
        <span class="n">ENDCG</span>
    <span class="p">}</span>
    
    <span class="c1">// Pass 2: 描边（只在物体外部）</span>
    <span class="n">Pass</span>
    <span class="p">{</span>
        <span class="n">Cull</span> <span class="n">Front</span>
        
        <span class="n">Stencil</span>
        <span class="p">{</span>
            <span class="n">Ref</span> <span class="mi">1</span>
            <span class="n">Comp</span> <span class="n">NotEqual</span>  <span class="c1">// 不等于1的地方（物体外部）</span>
        <span class="p">}</span>
        
        <span class="n">CGPROGRAM</span>
        <span class="c1">// 放大并渲染描边</span>
        <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">.</span><span class="n">xyz</span> <span class="o">+=</span> <span class="n">v</span><span class="p">.</span><span class="n">normal</span> <span class="o">*</span> <span class="n">_OutlineWidth</span><span class="p">;</span>
        <span class="n">ENDCG</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>示例3：传送门效果</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre><span class="c1">// 传送门遮罩</span>
<span class="n">Shader</span> <span class="s">"Custom/PortalMask"</span>
<span class="p">{</span>
    <span class="n">SubShader</span>
    <span class="p">{</span>
        <span class="n">Pass</span>
        <span class="p">{</span>
            <span class="n">ZWrite</span> <span class="n">Off</span>
            <span class="n">ColorMask</span> <span class="mi">0</span>
            
            <span class="n">Stencil</span>
            <span class="p">{</span>
                <span class="n">Ref</span> <span class="mi">1</span>
                <span class="n">Comp</span> <span class="n">Always</span>
                <span class="n">Pass</span> <span class="n">Replace</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 传送门另一侧的场景</span>
<span class="n">Shader</span> <span class="s">"Custom/PortalView"</span>
<span class="p">{</span>
    <span class="n">SubShader</span>
    <span class="p">{</span>
        <span class="n">Pass</span>
        <span class="p">{</span>
            <span class="n">Stencil</span>
            <span class="p">{</span>
                <span class="n">Ref</span> <span class="mi">1</span>
                <span class="n">Comp</span> <span class="n">Equal</span>
            <span class="p">}</span>
            
            <span class="n">CGPROGRAM</span>
            <span class="c1">// 渲染另一个场景</span>
            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="alphatomaskalpha转遮罩">AlphaToMask（Alpha转遮罩）</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">AlphaToMask</span> <span class="n">On</span>   <span class="c1">// 开启（MSAA时有效）</span>
<span class="n">AlphaToMask</span> <span class="n">Off</span>  <span class="c1">// 关闭（默认）</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>作用：</strong></p> <ul> <li>将Alpha值转换为覆盖遮罩</li> <li>用于抗锯齿（需要开启MSAA）</li> <li>适合植被等Alpha Test物体</li> </ul> <p><strong>应用场景：</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="c1">// 树叶Shader（更好的边缘）</span>
<span class="n">Pass</span>
<span class="p">{</span>
    <span class="n">AlphaToMask</span> <span class="n">On</span>
    
    <span class="n">CGPROGRAM</span>
    <span class="n">fixed4</span> <span class="n">frag</span><span class="p">()</span> <span class="o">:</span> <span class="n">SV_Target</span>
    <span class="p">{</span>
        <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
        <span class="n">clip</span><span class="p">(</span><span class="n">col</span><span class="p">.</span><span class="n">a</span> <span class="o">-</span> <span class="n">_Cutoff</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">col</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ENDCG</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="conservative保守光栅化">Conservative（保守光栅化）</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">Conservative</span> <span class="n">True</span>   <span class="c1">// 开启保守光栅化</span>
<span class="n">Conservative</span> <span class="n">False</span>  <span class="c1">// 关闭（默认）</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>作用：</strong></p> <ul> <li>高级功能，确保三角形完全覆盖的像素都被渲染</li> <li>需要硬件支持</li> </ul> <h2 id="常见组合总结">常见组合总结</h2> <table> <thead> <tr> <th>效果类型</th> <th>Cull</th> <th>ZTest</th> <th>ZWrite</th> <th>Blend</th> </tr> </thead> <tbody> <tr> <td>不透明物体</td> <td>Back</td> <td>LEqual</td> <td>On</td> <td>Off</td> </tr> <tr> <td>标准透明</td> <td>Back</td> <td>LEqual</td> <td>Off</td> <td>SrcAlpha OneMinusSrcAlpha</td> </tr> <tr> <td>加法粒子</td> <td>Off</td> <td>LEqual</td> <td>Off</td> <td>One One</td> </tr> <tr> <td>描边</td> <td>Front</td> <td>LEqual</td> <td>On</td> <td>Off</td> </tr> <tr> <td>UI</td> <td>Off</td> <td>Always</td> <td>Off</td> <td>SrcAlpha OneMinusSrcAlpha</td> </tr> <tr> <td>天空盒</td> <td>Front</td> <td>LEqual</td> <td>Off</td> <td>Off</td> </tr> <tr> <td>X光透视</td> <td>Back</td> <td>Greater</td> <td>Off</td> <td>SrcAlpha OneMinusSrcAlpha</td> </tr> </tbody> </table> <h2 id="target">target</h2> <p><strong><em>Shader Model版本，可以省略。Unity会使用默认值：target 2.5</em></strong></p> <h3 id="语法">语法</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="cp">#pragma target 2.0  // 指定最低Shader Model版本
#pragma target 2.5
#pragma target 3.0
#pragma target 3.5
#pragma target 4.0
#pragma target 4.5
#pragma target 5.0
#pragma target 6.0
</span></pre></td></tr></tbody></table></code></pre></div></div> <h3 id="unity的shader-model版本对照">Unity的Shader Model版本对照</h3> <table> <thead> <tr> <th>Unity Target</th> <th>Shader Model</th> <th>对应年代</th> <th>平台支持</th> <th>关键功能</th> </tr> </thead> <tbody> <tr> <td><strong>2.0</strong></td> <td>SM 2.0</td> <td>2004</td> <td>所有平台</td> <td>基础着色器</td> </tr> <tr> <td><strong>2.5</strong></td> <td>SM 2.0扩展</td> <td>2005</td> <td>PC, Console</td> <td>更多指令</td> </tr> <tr> <td><strong>3.0</strong></td> <td>SM 3.0</td> <td>2006</td> <td>PC, Console, 高端移动</td> <td>MRT, 更多插值器</td> </tr> <tr> <td><strong>3.5</strong> (GL ES 3.0)</td> <td>SM 3.0+</td> <td>2012</td> <td>现代移动</td> <td>MRT, Compute Shader</td> </tr> <tr> <td><strong>4.0</strong></td> <td>SM 4.0</td> <td>2008</td> <td>DX10+</td> <td>几何着色器</td> </tr> <tr> <td><strong>4.5</strong></td> <td>SM 4.5</td> <td>2009</td> <td>DX11+</td> <td>曲面细分</td> </tr> <tr> <td><strong>5.0</strong></td> <td>SM 5.0</td> <td>2011</td> <td>DX11+</td> <td>完整Compute Shader</td> </tr> <tr> <td><strong>6.0</strong></td> <td>SM 6.0</td> <td>2018</td> <td>DX12, Vulkan</td> <td>光线追踪、Mesh Shader</td> </tr> </tbody> </table> <h1 id="顶点片元着色器">顶点/片元着色器</h1> <h2 id="结构体">结构体</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">appdata</span>
<span class="p">{</span>
    <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>   <span class="c1">// 顶点位置</span>
    <span class="n">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>     <span class="c1">// 法线</span>
    <span class="n">float4</span> <span class="n">tangent</span> <span class="o">:</span> <span class="n">TANGENT</span><span class="p">;</span>   <span class="c1">// 切线</span>
    <span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>      <span class="c1">// UV0</span>
    <span class="n">float2</span> <span class="n">uv1</span> <span class="o">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>     <span class="c1">// UV1（光照贴图）</span>
    <span class="n">float4</span> <span class="n">color</span> <span class="o">:</span> <span class="n">COLOR</span><span class="p">;</span>       <span class="c1">// 顶点颜色</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>完整的顶点输入语义列表：</strong></p> <table> <thead> <tr> <th>语义</th> <th>含义</th> <th>数据类型</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">POSITION</code></td> <td>顶点位置（模型空间）</td> <td>float4</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">NORMAL</code></td> <td>法线（模型空间）</td> <td>float3</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">TANGENT</code></td> <td>切线（模型空间）</td> <td>float4</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">TEXCOORD0</code></td> <td>第一套UV</td> <td>float2/float4</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">TEXCOORD1</code></td> <td>第二套UV（光照贴图）</td> <td>float2/float4</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">TEXCOORD2</code></td> <td>第三套UV</td> <td>float2/float4</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">TEXCOORD3</code></td> <td>第四套UV</td> <td>float2/float4</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">COLOR</code></td> <td>顶点颜色</td> <td>float4</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_VertexID</code></td> <td>顶点ID</td> <td>uint</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_InstanceID</code></td> <td>实例ID（GPU Instancing）</td> <td>uint</td> </tr> </tbody> </table> <h2 id="texcoord的数量限制">TEXCOORD的数量限制</h2> <h3 id="不同shader-model的支持">不同Shader Model的支持</h3> <p>Shader Model 2.0：</p> <ul> <li>最多8个TEXCOORD（0-7）</li> <li>每个最多float4</li> <li>总共32个float Shader Model</li> <li>3.0：</li> <li>最多10个TEXCOORD（0-9）</li> <li>每个最多float4</li> <li>总共40个float Shader Model</li> <li>4.0+：</li> <li>最多16个插值器 - 使用不同的命名（但TEXCOORD仍然有效） Unity默认：</li> </ul> <h1 id="pragma-target-25">pragma target 2.5</h1> <ul> <li>支持10个TEXCOORD（0-9） 如果需要更多：</li> </ul> <h1 id="pragma-target-30-或更高">pragma target 3.0 或更高</h1> <h3 id="完整支持表"><strong>完整支持表</strong></h3> <table> <thead> <tr> <th>Shader Model</th> <th>TEXCOORD数量</th> <th>每个类型</th> <th>总float数</th> <th>Unity target</th> </tr> </thead> <tbody> <tr> <td>SM 2.0</td> <td>8 (0-7)</td> <td>float4</td> <td>32</td> <td>target 2.0</td> </tr> <tr> <td>SM 2.5</td> <td>10 (0-9)</td> <td>float4</td> <td>40</td> <td>target 2.5（默认）</td> </tr> <tr> <td>SM 3.0</td> <td>10 (0-9)</td> <td>float4</td> <td>40</td> <td>target 3.0</td> </tr> <tr> <td>SM 4.0+</td> <td>16</td> <td>float4</td> <td>64</td> <td>target 4.0+</td> </tr> </tbody> </table> <h1 id="片元输出语义">片元输出语义</h1> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">fixed4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>  <span class="c1">// ← 输出到渲染目标</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 输出红色</span>
<span class="err">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>常用输出语义：</strong> <strong><em>这里语义主要是声明在Struct中的，片元后面默认就SV_Target或者说是SV_Target0，如果多输出的话就可以不写</em></strong></p> <table> <thead> <tr> <th>语义</th> <th>含义</th> <th>用途</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">SV_Target</code></td> <td>渲染目标0</td> <td>输出颜色到屏幕</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_Target0</code></td> <td>渲染目标0</td> <td>同上（明确写0）</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_Target1</code></td> <td>渲染目标1</td> <td>多渲染目标（MRT）</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_Target2</code></td> <td>渲染目标2</td> <td>MRT</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_Target3</code></td> <td>渲染目标3</td> <td>MRT</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_Depth</code></td> <td>深度值</td> <td>自定义深度</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">COLOR</code></td> <td>颜色（旧版）</td> <td>被SV_Target取代</td> </tr> </tbody> </table> <h1 id="延迟管线">延迟管线</h1> <p><strong><em>多输出是使用延迟管线，先输出各个图，然后一起计算光照</em></strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="c1">// 必须用结构体 + MRT（但还是一个Pass！）</span>
<span class="k">struct</span> <span class="n">GBufferOutput</span>
<span class="p">{</span>
    <span class="n">fixed4</span> <span class="n">albedo</span> <span class="o">:</span> <span class="n">SV_Target0</span><span class="p">;</span>
    <span class="n">fixed4</span> <span class="n">specular</span> <span class="o">:</span> <span class="n">SV_Target1</span><span class="p">;</span>
    <span class="n">fixed4</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">SV_Target2</span><span class="p">;</span>
    <span class="n">fixed4</span> <span class="n">emission</span> <span class="o">:</span> <span class="n">SV_Target3</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">GBufferOutput</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">GBufferOutput</span> <span class="n">o</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">albedo</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">specular</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_SpecMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">UnpackNormal</span><span class="p">(</span><span class="n">tex2D</span><span class="p">(</span><span class="n">_BumpMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">));</span>
    <span class="n">o</span><span class="p">.</span><span class="n">emission</span> <span class="o">=</span> <span class="n">_Emission</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>  <span class="c1">// 同时输出4个值，只调用一次！</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h3 id="实现方法参考">实现方法参考</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="rouge-code"><pre><span class="n">SubShader</span>
<span class="p">{</span>
    <span class="n">Pass</span>
    <span class="p">{</span>
        <span class="n">CGPROGRAM</span>
        <span class="cp">#pragma vertex vert
</span>        <span class="cp">#pragma fragment frag
</span>        <span class="cp">#pragma target 3.0  // MRT需要SM3.0+
</span>        
        <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
        
        <span class="k">struct</span> <span class="n">v2f</span>
        <span class="p">{</span>
            <span class="n">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
            <span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
            <span class="n">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>
            <span class="kt">float</span> <span class="n">depth</span> <span class="o">:</span> <span class="n">TEXCOORD2</span><span class="p">;</span>
        <span class="p">};</span>
        
        <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata_base</span> <span class="n">v</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
            <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
            <span class="n">o</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">texcoord</span><span class="p">;</span>
            <span class="n">o</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
            <span class="n">o</span><span class="p">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">o</span><span class="p">.</span><span class="n">pos</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
        <span class="p">}</span>
        
        <span class="c1">// 定义多输出结构体</span>
        <span class="k">struct</span> <span class="n">FragOutput</span>
        <span class="p">{</span>
            <span class="n">fixed4</span> <span class="n">albedo</span> <span class="o">:</span> <span class="n">SV_Target0</span><span class="p">;</span>  <span class="c1">// 输出到RT0</span>
            <span class="n">fixed4</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">SV_Target1</span><span class="p">;</span>  <span class="c1">// 输出到RT1</span>
            <span class="n">fixed4</span> <span class="n">depth</span> <span class="o">:</span> <span class="n">SV_Target2</span><span class="p">;</span>   <span class="c1">// 输出到RT2</span>
        <span class="p">};</span>
        
        <span class="c1">// 一次frag调用，同时输出3个值</span>
        <span class="n">FragOutput</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">FragOutput</span> <span class="n">o</span><span class="p">;</span>
            
            <span class="c1">// 同时计算所有数据</span>
            <span class="n">o</span><span class="p">.</span><span class="n">albedo</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
            <span class="n">o</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normal</span><span class="p">)</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="n">o</span><span class="p">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">depth</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">depth</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">depth</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            
            <span class="c1">// 一次return，同时输出到3个RT</span>
            <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">ENDCG</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 优点：</span>
<span class="c1">// - 只执行一次顶点着色器</span>
<span class="c1">// - 只执行一次frag函数</span>
<span class="c1">// - GPU硬件支持，非常高效</span>
<span class="c1">// - 这就是延迟渲染的基础</span>
</pre></td></tr></tbody></table></code></pre></div></div> <hr/> <h2 id="c端如何接收多渲染目标">C#端如何接收多渲染目标</h2> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">UnityEngine</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">MRTExample</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">Shader</span> <span class="n">mrtShader</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">Material</span> <span class="n">mrtMaterial</span><span class="p">;</span>
    
    <span class="k">private</span> <span class="n">RenderTexture</span> <span class="n">rt0</span><span class="p">;</span>  <span class="c1">// Albedo</span>
    <span class="k">private</span> <span class="n">RenderTexture</span> <span class="n">rt1</span><span class="p">;</span>  <span class="c1">// Normal</span>
    <span class="k">private</span> <span class="n">RenderTexture</span> <span class="n">rt2</span><span class="p">;</span>  <span class="c1">// Depth</span>
    
    <span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// 创建3个RenderTexture</span>
        <span class="n">rt0</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RenderTexture</span><span class="p">(</span><span class="m">512</span><span class="p">,</span> <span class="m">512</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
        <span class="n">rt1</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RenderTexture</span><span class="p">(</span><span class="m">512</span><span class="p">,</span> <span class="m">512</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
        <span class="n">rt2</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RenderTexture</span><span class="p">(</span><span class="m">512</span><span class="p">,</span> <span class="m">512</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
        
        <span class="n">mrtMaterial</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Material</span><span class="p">(</span><span class="n">mrtShader</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">void</span> <span class="nf">OnRenderImage</span><span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 设置多渲染目标（MRT）</span>
        <span class="n">RenderBuffer</span><span class="p">[]</span> <span class="n">colorBuffers</span> <span class="p">=</span> <span class="k">new</span> <span class="n">RenderBuffer</span><span class="p">[</span><span class="m">3</span><span class="p">];</span>
        <span class="n">colorBuffers</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">rt0</span><span class="p">.</span><span class="n">colorBuffer</span><span class="p">;</span>  <span class="c1">// SV_Target0</span>
        <span class="n">colorBuffers</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">rt1</span><span class="p">.</span><span class="n">colorBuffer</span><span class="p">;</span>  <span class="c1">// SV_Target1</span>
        <span class="n">colorBuffers</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="n">rt2</span><span class="p">.</span><span class="n">colorBuffer</span><span class="p">;</span>  <span class="c1">// SV_Target2</span>
        
        <span class="c1">// 一次Graphics.Blit，同时输出到3个RT</span>
        <span class="n">Graphics</span><span class="p">.</span><span class="nf">SetRenderTarget</span><span class="p">(</span><span class="n">colorBuffers</span><span class="p">,</span> <span class="n">rt0</span><span class="p">.</span><span class="n">depthBuffer</span><span class="p">);</span>
        <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">mrtMaterial</span><span class="p">);</span>
        
        <span class="c1">// 现在rt0、rt1、rt2都已经填充了数据</span>
        <span class="c1">// 只调用了一次frag函数！</span>
        
        <span class="c1">// 显示结果</span>
        <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">rt0</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span>  <span class="c1">// 显示Albedo</span>
    <span class="p">}</span>
    
    <span class="c1">// 调试：显示3个RT</span>
    <span class="k">void</span> <span class="nf">OnGUI</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">GUI</span><span class="p">.</span><span class="nf">DrawTexture</span><span class="p">(</span><span class="k">new</span> <span class="nf">Rect</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">256</span><span class="p">,</span> <span class="m">256</span><span class="p">),</span> <span class="n">rt0</span><span class="p">);</span>
        <span class="n">GUI</span><span class="p">.</span><span class="nf">DrawTexture</span><span class="p">(</span><span class="k">new</span> <span class="nf">Rect</span><span class="p">(</span><span class="m">256</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">256</span><span class="p">,</span> <span class="m">256</span><span class="p">),</span> <span class="n">rt1</span><span class="p">);</span>
        <span class="n">GUI</span><span class="p">.</span><span class="nf">DrawTexture</span><span class="p">(</span><span class="k">new</span> <span class="nf">Rect</span><span class="p">(</span><span class="m">512</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">256</span><span class="p">,</span> <span class="m">256</span><span class="p">),</span> <span class="n">rt2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h1 id="数据类型快速参考表">数据类型快速参考表</h1> <h3 id="一精度类型对比"><strong>一、精度类型对比</strong></h3> <table> <thead> <tr> <th>精度类型</th> <th>位数</th> <th>范围</th> <th>精度</th> <th>桌面性能</th> <th>移动性能</th> <th>跨平台一致性</th> <th><strong>推荐度</strong></th> </tr> </thead> <tbody> <tr> <td><strong>half</strong></td> <td>16位</td> <td>±60000</td> <td>~0.001</td> <td>等于float</td> <td>⭐⭐⭐</td> <td>⭐⭐⭐⭐</td> <td>✅ <strong>主力</strong></td> </tr> <tr> <td><strong>float</strong></td> <td>32位</td> <td>±3.4×10³⁸</td> <td>~7位有效数字</td> <td>float</td> <td>⭐</td> <td>⭐⭐⭐⭐⭐</td> <td>✅ <strong>必要时</strong></td> </tr> <tr> <td><strong>fixed</strong></td> <td>11位</td> <td>[-2, 2]</td> <td>~0.004</td> <td>等于float</td> <td>⭐⭐⭐</td> <td>⭐⭐</td> <td>❌ <strong>避免</strong></td> </tr> </tbody> </table> <hr/> <h3 id="二常用数据类型精度选择"><strong>二、常用数据类型精度选择</strong></h3> <table> <thead> <tr> <th>数据类型</th> <th>推荐精度</th> <th>原因</th> <th>示例</th> </tr> </thead> <tbody> <tr> <td><strong>🎨 颜色（RGB/RGBA）</strong></td> <td><code class="language-plaintext highlighter-rouge">half4</code></td> <td>精度足够，跨平台一致</td> <td><code class="language-plaintext highlighter-rouge">half4 color</code></td> </tr> <tr> <td><strong>📐 法线</strong></td> <td><code class="language-plaintext highlighter-rouge">half3</code></td> <td>归一化向量，精度足够</td> <td><code class="language-plaintext highlighter-rouge">half3 normal</code></td> </tr> <tr> <td><strong>📐 切线/副切线</strong></td> <td><code class="language-plaintext highlighter-rouge">half3</code></td> <td>同法线</td> <td><code class="language-plaintext highlighter-rouge">half3 tangent</code></td> </tr> <tr> <td><strong>🗺️ UV坐标</strong></td> <td><code class="language-plaintext highlighter-rouge">half2</code></td> <td>通常小范围</td> <td><code class="language-plaintext highlighter-rouge">half2 uv</code></td> </tr> <tr> <td><strong>💡 光照方向</strong></td> <td><code class="language-plaintext highlighter-rouge">half3</code></td> <td>归一化向量</td> <td><code class="language-plaintext highlighter-rouge">half3 lightDir</code></td> </tr> <tr> <td><strong>👁️ 视线方向</strong></td> <td><code class="language-plaintext highlighter-rouge">half3</code></td> <td>归一化向量</td> <td><code class="language-plaintext highlighter-rouge">half3 viewDir</code></td> </tr> <tr> <td><strong>✖️ 点积结果（NdotL等）</strong></td> <td><code class="language-plaintext highlighter-rouge">half</code></td> <td>[-1,1]范围</td> <td><code class="language-plaintext highlighter-rouge">half ndotl</code></td> </tr> <tr> <td><strong>🎚️ PBR系数（金属度/粗糙度）</strong></td> <td><code class="language-plaintext highlighter-rouge">half</code></td> <td>[0,1]范围</td> <td><code class="language-plaintext highlighter-rouge">half metallic</code></td> </tr> <tr> <td><strong>🎭 遮罩/Alpha</strong></td> <td><code class="language-plaintext highlighter-rouge">half</code></td> <td>[0,1]范围</td> <td><code class="language-plaintext highlighter-rouge">half mask</code></td> </tr> <tr> <td><strong>📦 纹理采样结果</strong></td> <td><code class="language-plaintext highlighter-rouge">half4</code></td> <td>直接返回half</td> <td><code class="language-plaintext highlighter-rouge">half4 tex2D(...)</code></td> </tr> <tr> <td><strong>🌍 世界空间坐标</strong></td> <td><code class="language-plaintext highlighter-rouge">float3</code></td> <td>可能很大（几千米）</td> <td><code class="language-plaintext highlighter-rouge">float3 worldPos</code></td> </tr> <tr> <td><strong>📍 裁剪空间位置</strong></td> <td><code class="language-plaintext highlighter-rouge">float4</code></td> <td><strong>必须</strong>（SV_POSITION）</td> <td><code class="language-plaintext highlighter-rouge">float4 pos</code></td> </tr> <tr> <td><strong>🔢 矩阵</strong></td> <td><code class="language-plaintext highlighter-rouge">float4x4</code></td> <td>精度要求高</td> <td><code class="language-plaintext highlighter-rouge">float4x4 matrix</code></td> </tr> <tr> <td><strong>⏱️ 时间/累加计算</strong></td> <td><code class="language-plaintext highlighter-rouge">float</code></td> <td>避免精度损失</td> <td><code class="language-plaintext highlighter-rouge">float time</code></td> </tr> <tr> <td><strong>📏 大范围距离</strong></td> <td><code class="language-plaintext highlighter-rouge">float</code></td> <td>可能很大</td> <td><code class="language-plaintext highlighter-rouge">float distance</code></td> </tr> <tr> <td><strong>📐 复杂数学函数</strong></td> <td><code class="language-plaintext highlighter-rouge">float</code></td> <td>sin/cos/exp等</td> <td><code class="language-plaintext highlighter-rouge">float sine</code></td> </tr> </tbody> </table>]]></content><author><name></name></author><category term="TAMonth01"/><category term="shader"/><category term="rendering"/><category term="unity"/><summary type="html"><![CDATA[Built-in Shader结构速览]]></summary></entry><entry><title type="html">Lv.1 数学支线 3Blue1Brown线性代数</title><link href="https://xueqingzhe.github.io/blog/2025/Lv.1-%E6%95%B0%E5%AD%A6%E6%94%AF%E7%BA%BF-3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" rel="alternate" type="text/html" title="Lv.1 数学支线 3Blue1Brown线性代数"/><published>2025-12-21T00:00:00+00:00</published><updated>2025-12-21T00:00:00+00:00</updated><id>https://xueqingzhe.github.io/blog/2025/Lv.1%20%E6%95%B0%E5%AD%A6%E6%94%AF%E7%BA%BF%203Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0</id><content type="html" xml:base="https://xueqingzhe.github.io/blog/2025/Lv.1-%E6%95%B0%E5%AD%A6%E6%94%AF%E7%BA%BF-3Blue1Brown%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"><![CDATA[<h1 id="基向量">基向量</h1> <p><strong><em>坐标空间中会有对应轴的单位向量</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251206170850.png" alt="图片"/> <strong><em>向量就可以理解为由单位向量拉伸之后的和</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251206171009.png" alt="图片"/></p> <p><img src="/assets/img/TAMonth01/Pasted image 20251206171056.png" alt="图片"/> <img src="/assets/img/TAMonth01/Pasted image 20251206171134.png" alt="图片"/></p> <h1 id="张成空间">张成空间</h1> <p><strong><em>对于两个指定的基向量</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251206171455.png" alt="图片"/></p> <h2 id="固定一个向量">固定一个向量</h2> <p><strong><em>如果固定一个向量，另一个向量随意缩放，则会描绘出一条直线</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251206171521.png" alt="图片"/></p> <h2 id="不固定">不固定</h2> <p><strong><em>大部分情况下，可以到达平面所有的点</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251206171652.png" alt="图片"/> <strong><em>但当两个向量共线时，这时候会被限制在直线上</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251206171739.png" alt="图片"/> <strong><em>如果都是0向量，那么就只能在原点了</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251206171903.png" alt="图片"/> <strong>所有可以表示给定向量线性组合的向量的集合，被称作给定向量的张成空间</strong> <strong><em>可以理解为两个向量变化得到的所有情况得到的空间</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251206172100.png" alt="图片"/></p> <p><img src="/assets/img/TAMonth01/Pasted image 20251206172159.png" alt="图片"/> <strong><em>这里其实是在讨论，如果只通过向量加法和数乘，我们能得到怎样的结果，也就是张成空间</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251206172458.png" alt="图片"/></p> <h1 id="向量和点的关系">向量和点的关系</h1> <p><img src="/assets/img/TAMonth01/Pasted image 20251206172546.png" alt="图片"/> <strong><em>如果向量填满整个空间，那么会很拥挤</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251206172623.png" alt="图片"/> <strong><em>所以通常只用终点来描述向量，起点则是在原点</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251206172721.png" alt="图片"/> <strong><em>那么多个点，只要考虑对应的线就行</em></strong> <img src="/assets/img/TAMonth01/向量点到线.gif" alt="图片"/> <strong>这样就可以得到，两个向量的张成空间是一个平面</strong> <img src="/assets/img/TAMonth01/向量点到线2.gif" alt="图片"/></p> <h1 id="三维中">三维中</h1> <p><strong>那么在三维中也是同理，两个向量的张成空间是一个平面</strong>* <img src="/assets/img/TAMonth01/Pasted image 20251206174130.png" alt="图片"/> <img src="/assets/img/TAMonth01/Pasted image 20251206174217.png" alt="图片"/></p> <h2 id="如果加上第三个向量">如果加上第三个向量</h2> <p><strong><em>定义基本和二维一致</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251206174314.png" alt="图片"/> <img src="/assets/img/TAMonth01/Pasted image 20251206174340.png" alt="图片"/> <strong>如果第三个向量刚好在前两个向量形成的张成平面上，那么他们的张成空间不会发生变化</strong>* <img src="/assets/img/TAMonth01/Pasted image 20251206174411.png" alt="图片"/> <strong>但是在大多数情况下，第三个向量不会落在前两个向量张成的平面上，那么这意味着可以得到所有三维空间的平面</strong>* <img src="/assets/img/TAMonth01/三维向量张成空间.gif" alt="图片"/> <strong>当有一个向量落在其他两个向量的平面中，或者和其中一个共线，移除这个向量不影响张成空间，那么可以说明这个向量与其它两个向量线性相关</strong> <img src="/assets/img/TAMonth01/三维向量线性相关.gif" alt="图片"/> <strong>反之，如果一个向量增加了原来的维度，那么 称为线性无关</strong>* <img src="/assets/img/TAMonth01/Pasted image 20251206175813.png" alt="图片"/></p> <h1 id="基向量的定义">基向量的定义</h1> <p><strong><em>所以基向量定义，是拿一个向量出来都会增加维度，和另外两个向量线性无关，注意这里没有说基向量是互相垂直，互相垂直是坐标系的要求</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251206175926.png" alt="图片"/></p> <h1 id="变换">变换</h1> <h2 id="线性变换">线性变换</h2> <p><strong><em>变换的本质可以理解为函数，但变换一词意指可视化的运动</em></strong> <img src="/assets/img/TAMonth01/线性变换.gif" alt="图片"/> <strong>线性变换的要求，直线必须保持且原点不变</strong>* <img src="/assets/img/TAMonth01/Pasted image 20251206181635.png" alt="图片"/> <strong>或者说网格平行且等距分布</strong>* <img src="/assets/img/TAMonth01/Pasted image 20251206181930.png" alt="图片"/> <strong>如果保持直线，原点移动的话，虽然不是线性变换，但是是仿射变换</strong> <img src="/assets/img/TAMonth01/Pasted image 20251206181746.png" alt="图片"/></p> <h2 id="如何用数值描述线性变换">如何用数值描述线性变换</h2> <p><img src="/assets/img/TAMonth01/Pasted image 20251206182036.png" alt="图片"/> <strong>只需要记住基向量的变换后的位置</strong>* <img src="/assets/img/TAMonth01/Pasted image 20251206182155.png" alt="图片"/> <strong>一个向量由基向量计算得来，那么线性变换后依然满足</strong>* <img src="/assets/img/TAMonth01/Pasted image 20251206182324.png" alt="图片"/></p> <h2 id="线性变换矩阵缩放旋转">线性变换矩阵(缩放旋转)</h2> <p><strong>变换后的基向量</strong>* <img src="/assets/img/TAMonth01/Pasted image 20251206182651.png" alt="图片"/> <strong>转换成矩阵形式，这里实际涵盖了缩放和旋转</strong> <img src="/assets/img/TAMonth01/Pasted image 20251206182757.png" alt="图片"/><strong>如果想要计算变换后的向量位置，那么只需要和矩阵进行计算</strong> <img src="/assets/img/TAMonth01/Pasted image 20251206182943.png" alt="图片"/></p> <p><img src="/assets/img/TAMonth01/Pasted image 20251206183040.png" alt="图片"/><img src="/assets/img/TAMonth01/Pasted image 20251206183108.png" alt="图片"/></p> <h2 id="剪切切变shear">剪切（切变）Shear</h2> <p><strong>这里相当于只有一个基向量发生变化，那么只需要将需要变换的向量和这个改变过的基向量相乘就行</strong>* <img src="/assets/img/TAMonth01/Pasted image 20251206184601.png" alt="图片"/></p> <h1 id="矩阵乘法与线性变换复合的联系">矩阵乘法与线性变换复合的联系</h1> <h2 id="复合变换">复合变换</h2> <p><strong>先旋转，再剪切，这样多次变换就是复合变换</strong> <img src="/assets/img/TAMonth01/复合变换先旋转再剪切.gif" alt="图片"/> <strong>这里依旧可以追踪基向量的变化来得到复合变换矩阵，这个复合矩阵表示了总体的变换效果</strong>* <img src="/assets/img/TAMonth01/Pasted image 20251207185129.png" alt="图片"/></p> <h3 id="矩阵的计算顺序">矩阵的计算顺序</h3> <p><strong>矩阵计算需要从右到左运算，运算结果应该和使用复合矩阵变换是一致的</strong> <img src="/assets/img/TAMonth01/Pasted image 20251207185358.png" alt="图片"/> <strong>计算顺序来源于函数的表达式</strong>* <img src="/assets/img/TAMonth01/Pasted image 20251207185809.png" alt="图片"/></p>]]></content><author><name></name></author><category term="TAMonth01"/><category term="shader"/><category term="rendering"/><category term="unity"/><summary type="html"><![CDATA[3Blue1Brown线性代数简记]]></summary></entry><entry><title type="html">Blinn-Phong 半程向量（Halfway Vector）可视化</title><link href="https://xueqingzhe.github.io/blog/2025/Blinn-Phong-%E5%8D%8A%E7%A8%8B%E5%90%91%E9%87%8F-Halfway-Vector-%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="alternate" type="text/html" title="Blinn-Phong 半程向量（Halfway Vector）可视化"/><published>2025-12-21T00:00:00+00:00</published><updated>2025-12-21T00:00:00+00:00</updated><id>https://xueqingzhe.github.io/blog/2025/Blinn-Phong%20%E5%8D%8A%E7%A8%8B%E5%90%91%E9%87%8F%EF%BC%88Halfway%20Vector%EF%BC%89%E5%8F%AF%E8%A7%86%E5%8C%96</id><content type="html" xml:base="https://xueqingzhe.github.io/blog/2025/Blinn-Phong-%E5%8D%8A%E7%A8%8B%E5%90%91%E9%87%8F-Halfway-Vector-%E5%8F%AF%E8%A7%86%E5%8C%96/"><![CDATA[<iframe src="/assets/html/blinn_phong_visualization.html" width="100%" height="1200px" frameborder="0"> </iframe>]]></content><author><name></name></author><category term="TAMonth01"/><category term="shader"/><category term="rendering"/><category term="unity"/><summary type="html"><![CDATA[Blinn-Phong 半程向量（Halfway Vector）可视化]]></summary></entry><entry><title type="html">Lv.1 Unity主线：Unity函数常用速查</title><link href="https://xueqingzhe.github.io/blog/2025/Lv.1-Unity%E4%B8%BB%E7%BA%BF-Unity%E5%87%BD%E6%95%B0%E5%B8%B8%E7%94%A8%E9%80%9F%E6%9F%A5/" rel="alternate" type="text/html" title="Lv.1 Unity主线：Unity函数常用速查"/><published>2025-12-21T00:00:00+00:00</published><updated>2025-12-21T00:00:00+00:00</updated><id>https://xueqingzhe.github.io/blog/2025/Lv.1%20Unity%E4%B8%BB%E7%BA%BF%EF%BC%9AUnity%E5%87%BD%E6%95%B0%E5%B8%B8%E7%94%A8%E9%80%9F%E6%9F%A5</id><content type="html" xml:base="https://xueqingzhe.github.io/blog/2025/Lv.1-Unity%E4%B8%BB%E7%BA%BF-Unity%E5%87%BD%E6%95%B0%E5%B8%B8%E7%94%A8%E9%80%9F%E6%9F%A5/"><![CDATA[<h1 id="常用">常用</h1> <h3 id="最常用的函数">最常用的函数</h3> <table> <thead> <tr> <th>排名</th> <th>函数</th> <th>用途</th> <th>频率</th> </tr> </thead> <tbody> <tr> <td>1</td> <td><strong>UnityObjectToClipPos</strong></td> <td>顶点变换</td> <td>⭐⭐⭐⭐⭐</td> </tr> <tr> <td>2</td> <td><strong>UnityObjectToWorldNormal</strong></td> <td>法线变换</td> <td>⭐⭐⭐⭐⭐</td> </tr> <tr> <td>3</td> <td><strong>UnityObjectToWorldDIr</strong></td> <td>切线变换</td> <td>⭐⭐⭐⭐⭐</td> </tr> <tr> <td>4</td> <td><strong>normalize</strong></td> <td>向量归一化</td> <td>⭐⭐⭐⭐⭐</td> </tr> <tr> <td>5</td> <td><strong>dot</strong></td> <td>点积（光照）</td> <td>⭐⭐⭐⭐⭐</td> </tr> <tr> <td>6</td> <td><strong>tex2D</strong></td> <td>纹理采样</td> <td>⭐⭐⭐⭐⭐</td> </tr> <tr> <td>7</td> <td><strong>UnityWorldSpaceLightDir</strong></td> <td>光照方向</td> <td>⭐⭐⭐⭐</td> </tr> <tr> <td>8</td> <td><strong>UnityWorldSpaceViewDir</strong></td> <td>视线方向</td> <td>⭐⭐⭐⭐</td> </tr> <tr> <td>9</td> <td><strong>mul(unity_ObjectToWorld, v.vertex)</strong></td> <td>世界坐标</td> <td>⭐⭐⭐⭐</td> </tr> <tr> <td>10</td> <td><strong>lerp</strong></td> <td>插值混合</td> <td>⭐⭐⭐⭐</td> </tr> <tr> <td>11</td> <td><strong>saturate</strong></td> <td>限制[0,1]</td> <td>⭐⭐⭐</td> </tr> <tr> <td>12</td> <td><strong>TRANSFORM_TEX(v.texcoord, _MainTex)</strong></td> <td>UV控制</td> <td>⭐⭐⭐⭐⭐</td> </tr> <tr> <td>13</td> <td><strong>clip();</strong></td> <td>裁剪</td> <td>⭐⭐⭐⭐</td> </tr> </tbody> </table> <hr/> <h3 id="最常用的5个矩阵">最常用的5个矩阵</h3> <table> <thead> <tr> <th>排名</th> <th>矩阵</th> <th>变换</th> <th>频率</th> </tr> </thead> <tbody> <tr> <td>1</td> <td><strong>unity_ObjectToWorld</strong></td> <td>模型→世界</td> <td>⭐⭐⭐⭐⭐</td> </tr> <tr> <td>2</td> <td><strong>UNITY_MATRIX_MVP</strong></td> <td>模型→裁剪</td> <td>⭐⭐⭐⭐</td> </tr> <tr> <td>3</td> <td><strong>UNITY_MATRIX_V</strong></td> <td>世界→视图</td> <td>⭐⭐⭐</td> </tr> <tr> <td>4</td> <td><strong>UNITY_MATRIX_P</strong></td> <td>视图→裁剪</td> <td>⭐⭐⭐</td> </tr> <tr> <td>5</td> <td><strong>UNITY_MATRIX_VP</strong></td> <td>世界→裁剪</td> <td>⭐⭐⭐</td> </tr> </tbody> </table> <h1 id="全部">全部</h1> <h2 id="一unity坐标空间变换函数总表">一、Unity坐标空间变换函数总表</h2> <h3 id="位置变换函数"><strong>位置变换函数</strong></h3> <table> <thead> <tr> <th>函数名</th> <th>输入</th> <th>输出</th> <th>说明</th> <th>示例</th> </tr> </thead> <tbody> <tr> <td><strong>UnityObjectToClipPos</strong></td> <td>模型空间位置</td> <td>裁剪空间位置</td> <td>最常用，模型→裁剪</td> <td><code class="language-plaintext highlighter-rouge">float4 clipPos = UnityObjectToClipPos(v.vertex);</code></td> </tr> <tr> <td><strong>UnityObjectToViewPos</strong></td> <td>模型空间位置</td> <td>视图空间位置</td> <td>模型→视图</td> <td><code class="language-plaintext highlighter-rouge">float3 viewPos = UnityObjectToViewPos(v.vertex);</code></td> </tr> <tr> <td><strong>UnityWorldToViewPos</strong></td> <td>世界空间位置</td> <td>视图空间位置</td> <td>世界→视图</td> <td><code class="language-plaintext highlighter-rouge">float3 viewPos = UnityWorldToViewPos(worldPos);</code></td> </tr> <tr> <td><strong>UnityWorldToClipPos</strong></td> <td>世界空间位置</td> <td>裁剪空间位置</td> <td>世界→裁剪</td> <td><code class="language-plaintext highlighter-rouge">float4 clipPos = UnityWorldToClipPos(worldPos);</code></td> </tr> <tr> <td><strong>mul(unity_ObjectToWorld, v.vertex)</strong></td> <td>模型空间位置</td> <td>世界空间位置</td> <td>模型→世界（手动）</td> <td><code class="language-plaintext highlighter-rouge">float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</code></td> </tr> </tbody> </table> <hr/> <h3 id="方向法线变换函数"><strong>方向/法线变换函数</strong></h3> <table> <thead> <tr> <th>函数名</th> <th>输入</th> <th>输出</th> <th>说明</th> <th>示例</th> </tr> </thead> <tbody> <tr> <td><strong>UnityObjectToWorldNormal</strong></td> <td>模型空间法线</td> <td>世界空间法线</td> <td>自动处理转置逆</td> <td><code class="language-plaintext highlighter-rouge">float3 worldNormal = UnityObjectToWorldNormal(v.normal);</code></td> </tr> <tr> <td><strong>UnityObjectToWorldDir</strong></td> <td>模型空间方向</td> <td>世界空间方向</td> <td>方向向量变换</td> <td><code class="language-plaintext highlighter-rouge">float3 worldDir = UnityObjectToWorldDir(v.tangent.xyz);</code></td> </tr> <tr> <td><strong>UnityWorldToObjectDir</strong></td> <td>世界空间方向</td> <td>模型空间方向</td> <td>反向变换</td> <td><code class="language-plaintext highlighter-rouge">float3 objDir = UnityWorldToObjectDir(lightDir);</code></td> </tr> </tbody> </table> <hr/> <h3 id="光照相关函数"><strong>光照相关函数</strong></h3> <table> <thead> <tr> <th>函数名</th> <th>输入</th> <th>输出</th> <th>说明</th> <th>示例</th> </tr> </thead> <tbody> <tr> <td><strong>UnityWorldSpaceLightDir</strong></td> <td>世界空间位置</td> <td>光源方向（世界空间）</td> <td>自动处理点光源/方向光</td> <td><code class="language-plaintext highlighter-rouge">float3 lightDir = UnityWorldSpaceLightDir(worldPos);</code></td> </tr> <tr> <td><strong>ObjSpaceLightDir</strong></td> <td>模型空间位置</td> <td>光源方向（模型空间）</td> <td>模型空间光照</td> <td><code class="language-plaintext highlighter-rouge">float3 lightDir = ObjSpaceLightDir(v.vertex);</code></td> </tr> <tr> <td><strong>UnityWorldSpaceViewDir</strong></td> <td>世界空间位置</td> <td>视线方向（世界空间）</td> <td>从顶点指向相机</td> <td><code class="language-plaintext highlighter-rouge">float3 viewDir = UnityWorldSpaceViewDir(worldPos);</code></td> </tr> <tr> <td><strong>ObjSpaceViewDir</strong></td> <td>模型空间位置</td> <td>视线方向（模型空间）</td> <td>模型空间视线</td> <td><code class="language-plaintext highlighter-rouge">float3 viewDir = ObjSpaceViewDir(v.vertex);</code></td> </tr> </tbody> </table> <hr/> <h3 id="屏幕空间相关函数"><strong>屏幕空间相关函数</strong></h3> <table> <thead> <tr> <th>函数名</th> <th>输入</th> <th>输出</th> <th>说明</th> <th>示例</th> </tr> </thead> <tbody> <tr> <td><strong>ComputeScreenPos</strong></td> <td>裁剪空间位置</td> <td>屏幕空间位置</td> <td>用于屏幕特效</td> <td><code class="language-plaintext highlighter-rouge">float4 screenPos = ComputeScreenPos(clipPos);</code></td> </tr> <tr> <td><strong>ComputeGrabScreenPos</strong></td> <td>裁剪空间位置</td> <td>抓取屏幕位置</td> <td>用于折射等效果</td> <td><code class="language-plaintext highlighter-rouge">float4 grabPos = ComputeGrabScreenPos(clipPos);</code></td> </tr> </tbody> </table> <hr/> <h3 id="深度相关函数"><strong>深度相关函数</strong></h3> <table> <thead> <tr> <th>函数名</th> <th>输入</th> <th>输出</th> <th>说明</th> <th>示例</th> </tr> </thead> <tbody> <tr> <td><strong>COMPUTE_EYEDEPTH</strong></td> <td>SV_POSITION</td> <td>线性眼空间深度</td> <td>计算深度值</td> <td><code class="language-plaintext highlighter-rouge">COMPUTE_EYEDEPTH(o.depth);</code></td> </tr> <tr> <td><strong>DECODE_EYEDEPTH</strong></td> <td>深度纹理值</td> <td>线性眼空间深度</td> <td>解码深度</td> <td><code class="language-plaintext highlighter-rouge">float depth = DECODE_EYEDEPTH(depthTex);</code></td> </tr> <tr> <td><strong>Linear01Depth</strong></td> <td>深度缓冲值</td> <td>[0,1]线性深度</td> <td>深度值线性化</td> <td><code class="language-plaintext highlighter-rouge">float depth = Linear01Depth(depthValue);</code></td> </tr> <tr> <td><strong>LinearEyeDepth</strong></td> <td>深度缓冲值</td> <td>眼空间线性深度</td> <td>实际距离</td> <td><code class="language-plaintext highlighter-rouge">float depth = LinearEyeDepth(depthValue);</code></td> </tr> </tbody> </table> <hr/> <h2 id="二unity变换矩阵总表">二、Unity变换矩阵总表</h2> <h3 id="基础变换矩阵"><strong>基础变换矩阵</strong></h3> <table> <thead> <tr> <th>矩阵名</th> <th>类型</th> <th>变换</th> <th>说明</th> <th>使用示例</th> </tr> </thead> <tbody> <tr> <td><strong>unity_ObjectToWorld</strong></td> <td>float4x4</td> <td>模型→世界</td> <td>M矩阵</td> <td><code class="language-plaintext highlighter-rouge">float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;</code></td> </tr> <tr> <td><strong>unity_WorldToObject</strong></td> <td>float4x4</td> <td>世界→模型</td> <td>M逆矩阵</td> <td><code class="language-plaintext highlighter-rouge">float3 objPos = mul(unity_WorldToObject, worldPos).xyz;</code></td> </tr> <tr> <td><strong>UNITY_MATRIX_V</strong></td> <td>float4x4</td> <td>世界→视图</td> <td>V矩阵（视图矩阵）</td> <td><code class="language-plaintext highlighter-rouge">float3 viewPos = mul(UNITY_MATRIX_V, worldPos).xyz;</code></td> </tr> <tr> <td><strong>UNITY_MATRIX_I_V</strong></td> <td>float4x4</td> <td>视图→世界</td> <td>V逆矩阵</td> <td><code class="language-plaintext highlighter-rouge">float3 worldPos = mul(UNITY_MATRIX_I_V, viewPos).xyz;</code></td> </tr> <tr> <td><strong>UNITY_MATRIX_P</strong></td> <td>float4x4</td> <td>视图→裁剪</td> <td>P矩阵（投影矩阵）</td> <td><code class="language-plaintext highlighter-rouge">float4 clipPos = mul(UNITY_MATRIX_P, viewPos);</code></td> </tr> </tbody> </table> <hr/> <h3 id="组合变换矩阵"><strong>组合变换矩阵</strong></h3> <table> <thead> <tr> <th>矩阵名</th> <th>类型</th> <th>变换</th> <th>等价于</th> <th>使用示例</th> </tr> </thead> <tbody> <tr> <td><strong>UNITY_MATRIX_VP</strong></td> <td>float4x4</td> <td>世界→裁剪</td> <td>P × V</td> <td><code class="language-plaintext highlighter-rouge">float4 clipPos = mul(UNITY_MATRIX_VP, worldPos);</code></td> </tr> <tr> <td><strong>UNITY_MATRIX_MVP</strong></td> <td>float4x4</td> <td>模型→裁剪</td> <td>P × V × M</td> <td><code class="language-plaintext highlighter-rouge">float4 clipPos = mul(UNITY_MATRIX_MVP, v.vertex);</code></td> </tr> <tr> <td><strong>UNITY_MATRIX_MV</strong></td> <td>float4x4</td> <td>模型→视图</td> <td>V × M</td> <td><code class="language-plaintext highlighter-rouge">float3 viewPos = mul(UNITY_MATRIX_MV, v.vertex).xyz;</code></td> </tr> <tr> <td><strong>UNITY_MATRIX_IT_MV</strong></td> <td>float4x4</td> <td>法线变换（模型→视图）</td> <td>(MV)^-T（转置逆）</td> <td><code class="language-plaintext highlighter-rouge">float3 viewNormal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal);</code></td> </tr> </tbody> </table> <hr/> <h3 id="特殊矩阵"><strong>特殊矩阵</strong></h3> <table> <thead> <tr> <th>矩阵名</th> <th>类型</th> <th>说明</th> <th>使用场景</th> </tr> </thead> <tbody> <tr> <td><strong>unity_MatrixInvP</strong></td> <td>float4x4</td> <td>投影矩阵的逆</td> <td>深度重建世界坐标</td> </tr> <tr> <td><strong>unity_MatrixInvVP</strong></td> <td>float4x4</td> <td>VP矩阵的逆</td> <td>屏幕坐标→世界坐标</td> </tr> <tr> <td><strong>unity_WorldToCamera</strong></td> <td>float4x4</td> <td>世界→相机矩阵</td> <td>等同于UNITY_MATRIX_V</td> </tr> <tr> <td><strong>unity_CameraToWorld</strong></td> <td>float4x4</td> <td>相机→世界矩阵</td> <td>等同于UNITY_MATRIX_I_V</td> </tr> </tbody> </table> <hr/> <h2 id="三空间变换流程对照表">三、空间变换流程对照表</h2> <h3 id="完整变换链"><strong>完整变换链</strong></h3> <table> <thead> <tr> <th>空间</th> <th>坐标范围</th> <th>如何到达</th> <th>常用矩阵/函数</th> <th>用途</th> </tr> </thead> <tbody> <tr> <td><strong>模型空间</strong></td> <td>物体局部坐标</td> <td>从Mesh读取</td> <td><code class="language-plaintext highlighter-rouge">v.vertex</code></td> <td>顶点动画、物体局部效果</td> </tr> <tr> <td>↓</td> <td> </td> <td><strong>M矩阵</strong></td> <td><code class="language-plaintext highlighter-rouge">unity_ObjectToWorld</code></td> <td> </td> </tr> <tr> <td><strong>世界空间</strong></td> <td>场景全局坐标</td> <td><code class="language-plaintext highlighter-rouge">mul(unity_ObjectToWorld, v.vertex)</code></td> <td><code class="language-plaintext highlighter-rouge">UnityObjectToWorldNormal</code></td> <td>光照计算、物体交互</td> </tr> <tr> <td>↓</td> <td> </td> <td><strong>V矩阵</strong></td> <td><code class="language-plaintext highlighter-rouge">UNITY_MATRIX_V</code></td> <td> </td> </tr> <tr> <td><strong>视图空间</strong></td> <td>相机为原点</td> <td><code class="language-plaintext highlighter-rouge">mul(UNITY_MATRIX_V, worldPos)</code></td> <td><code class="language-plaintext highlighter-rouge">UnityWorldToViewPos</code></td> <td>雾效、深度计算</td> </tr> <tr> <td>↓</td> <td> </td> <td><strong>P矩阵</strong></td> <td><code class="language-plaintext highlighter-rouge">UNITY_MATRIX_P</code></td> <td> </td> </tr> <tr> <td><strong>裁剪空间</strong></td> <td>(x,y,z,w)</td> <td><code class="language-plaintext highlighter-rouge">UnityObjectToClipPos(v.vertex)</code></td> <td><code class="language-plaintext highlighter-rouge">UNITY_MATRIX_MVP</code></td> <td>输出到SV_POSITION</td> </tr> <tr> <td>↓</td> <td> </td> <td><strong>透视除法</strong></td> <td>硬件自动</td> <td> </td> </tr> <tr> <td><strong>NDC空间</strong></td> <td>[-1,1]或[0,1]</td> <td><code class="language-plaintext highlighter-rouge">/w</code>（硬件）</td> <td>-</td> <td>归一化坐标</td> </tr> <tr> <td>↓</td> <td> </td> <td><strong>视口变换</strong></td> <td>硬件自动</td> <td> </td> </tr> <tr> <td><strong>屏幕空间</strong></td> <td>像素坐标</td> <td><code class="language-plaintext highlighter-rouge">ComputeScreenPos</code></td> <td>-</td> <td>屏幕特效、UI</td> </tr> </tbody> </table> <hr/> <h2 id="四常用变换组合速查表">四、常用变换组合速查表</h2> <h3 id="位置变换快速查询"><strong>位置变换快速查询</strong></h3> <table> <thead> <tr> <th>从 → 到</th> <th>方法1（函数）</th> <th>方法2（矩阵）</th> <th>推荐</th> </tr> </thead> <tbody> <tr> <td><strong>模型 → 世界</strong></td> <td>-</td> <td><code class="language-plaintext highlighter-rouge">mul(unity_ObjectToWorld, v.vertex).xyz</code></td> <td>矩阵</td> </tr> <tr> <td><strong>模型 → 视图</strong></td> <td><code class="language-plaintext highlighter-rouge">UnityObjectToViewPos(v.vertex)</code></td> <td><code class="language-plaintext highlighter-rouge">mul(UNITY_MATRIX_MV, v.vertex).xyz</code></td> <td>函数</td> </tr> <tr> <td><strong>模型 → 裁剪</strong></td> <td><code class="language-plaintext highlighter-rouge">UnityObjectToClipPos(v.vertex)</code></td> <td><code class="language-plaintext highlighter-rouge">mul(UNITY_MATRIX_MVP, v.vertex)</code></td> <td>函数⭐</td> </tr> <tr> <td><strong>世界 → 视图</strong></td> <td><code class="language-plaintext highlighter-rouge">UnityWorldToViewPos(worldPos)</code></td> <td><code class="language-plaintext highlighter-rouge">mul(UNITY_MATRIX_V, float4(worldPos, 1)).xyz</code></td> <td>函数</td> </tr> <tr> <td><strong>世界 → 裁剪</strong></td> <td><code class="language-plaintext highlighter-rouge">UnityWorldToClipPos(worldPos)</code></td> <td><code class="language-plaintext highlighter-rouge">mul(UNITY_MATRIX_VP, float4(worldPos, 1))</code></td> <td>函数</td> </tr> <tr> <td><strong>视图 → 裁剪</strong></td> <td>-</td> <td><code class="language-plaintext highlighter-rouge">mul(UNITY_MATRIX_P, float4(viewPos, 1))</code></td> <td>矩阵</td> </tr> </tbody> </table> <hr/> <h3 id="法线方向变换快速查询"><strong>法线/方向变换快速查询</strong></h3> <table> <thead> <tr> <th>从 → 到</th> <th>方法1（函数）</th> <th>方法2（矩阵）</th> <th>推荐</th> <th>注意事项</th> </tr> </thead> <tbody> <tr> <td><strong>模型法线 → 世界</strong></td> <td><code class="language-plaintext highlighter-rouge">UnityObjectToWorldNormal(v.normal)</code></td> <td><code class="language-plaintext highlighter-rouge">mul((float3x3)unity_WorldToObject, v.normal)</code></td> <td>函数⭐</td> <td>自动转置逆</td> </tr> <tr> <td><strong>模型方向 → 世界</strong></td> <td><code class="language-plaintext highlighter-rouge">UnityObjectToWorldDir(v.tangent.xyz)</code></td> <td><code class="language-plaintext highlighter-rouge">mul((float3x3)unity_ObjectToWorld, dir)</code></td> <td>函数</td> <td>不需要转置逆</td> </tr> <tr> <td><strong>世界方向 → 模型</strong></td> <td><code class="language-plaintext highlighter-rouge">UnityWorldToObjectDir(worldDir)</code></td> <td><code class="language-plaintext highlighter-rouge">mul((float3x3)unity_WorldToObject, dir)</code></td> <td>函数</td> <td>-</td> </tr> </tbody> </table> <hr/> <h2 id="五光照计算常用函数表">五、光照计算常用函数表</h2> <h3 id="光照方向获取"><strong>光照方向获取</strong></h3> <table> <thead> <tr> <th>函数</th> <th>输入空间</th> <th>输出</th> <th>光源类型支持</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><strong>UnityWorldSpaceLightDir(worldPos)</strong></td> <td>世界空间位置</td> <td>世界空间光源方向</td> <td>方向光、点光源、聚光灯</td> <td>自动处理衰减</td> </tr> <tr> <td><strong>ObjSpaceLightDir(v.vertex)</strong></td> <td>模型空间位置</td> <td>模型空间光源方向</td> <td>方向光、点光源、聚光灯</td> <td>模型空间光照</td> </tr> <tr> <td><strong>_WorldSpaceLightPos0</strong></td> <td>-</td> <td>世界空间光源位置/方向</td> <td>主光源</td> <td>方向光时为方向向量</td> </tr> </tbody> </table> <hr/> <h3 id="视线方向获取"><strong>视线方向获取</strong></h3> <table> <thead> <tr> <th>函数</th> <th>输入空间</th> <th>输出</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><strong>UnityWorldSpaceViewDir(worldPos)</strong></td> <td>世界空间位置</td> <td>世界空间视线方向</td> <td>从顶点指向相机</td> </tr> <tr> <td><strong>ObjSpaceViewDir(v.vertex)</strong></td> <td>模型空间位置</td> <td>模型空间视线方向</td> <td>模型空间视线</td> </tr> <tr> <td><strong>_WorldSpaceCameraPos</strong></td> <td>-</td> <td>世界空间相机位置</td> <td>相机位置</td> </tr> </tbody> </table> <hr/> <h3 id="光照颜色属性"><strong>光照颜色/属性</strong></h3> <table> <thead> <tr> <th>变量名</th> <th>类型</th> <th>说明</th> <th>使用场景</th> </tr> </thead> <tbody> <tr> <td><strong>_LightColor0</strong></td> <td>fixed4</td> <td>主光源颜色</td> <td>前向渲染</td> </tr> <tr> <td><strong>UNITY_LIGHTMODEL_AMBIENT</strong></td> <td>fixed4</td> <td>环境光颜色</td> <td>所有管线</td> </tr> <tr> <td><strong>unity_SHAr, unity_SHAg, unity_SHAb</strong></td> <td>float4</td> <td>球谐光照</td> <td>间接光照</td> </tr> </tbody> </table> <hr/> <h2 id="六纹理采样相关函数表">六、纹理采样相关函数表</h2> <h3 id="基础采样函数"><strong>基础采样函数</strong></h3> <table> <thead> <tr> <th>函数</th> <th>说明</th> <th>Shader Model要求</th> <th>示例</th> </tr> </thead> <tbody> <tr> <td><strong>tex2D(sampler, uv)</strong></td> <td>2D纹理采样</td> <td>2.0+</td> <td><code class="language-plaintext highlighter-rouge">fixed4 col = tex2D(_MainTex, i.uv);</code></td> </tr> <tr> <td><strong>tex2Dlod(sampler, float4(uv, 0, mip))</strong></td> <td>指定mipmap层级</td> <td>3.0+</td> <td><code class="language-plaintext highlighter-rouge">fixed4 col = tex2Dlod(_MainTex, float4(i.uv, 0, 0));</code></td> </tr> <tr> <td><strong>tex2Dproj(sampler, float4)</strong></td> <td>投影纹理采样</td> <td>2.0+</td> <td><code class="language-plaintext highlighter-rouge">fixed4 col = tex2Dproj(_MainTex, screenPos);</code></td> </tr> <tr> <td><strong>tex2Dbias(sampler, float4(uv, 0, bias))</strong></td> <td>带偏移的采样</td> <td>2.0+</td> <td><code class="language-plaintext highlighter-rouge">fixed4 col = tex2Dbias(_MainTex, float4(i.uv, 0, -1));</code></td> </tr> </tbody> </table> <hr/> <h3 id="纹理采样urphdrp"><strong>纹理采样（URP/HDRP）</strong></h3> <table> <thead> <tr> <th>函数</th> <th>说明</th> <th>示例</th> </tr> </thead> <tbody> <tr> <td><strong>SAMPLE_TEXTURE2D(tex, sampler, uv)</strong></td> <td>URP/HDRP标准采样</td> <td><code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);</code></td> </tr> <tr> <td><strong>SAMPLE_TEXTURE2D_LOD(tex, sampler, uv, lod)</strong></td> <td>指定LOD</td> <td><code class="language-plaintext highlighter-rouge">SAMPLE_TEXTURE2D_LOD(_MainTex, sampler_MainTex, i.uv, 0);</code></td> </tr> <tr> <td><strong>SAMPLE_DEPTH_TEXTURE(tex, sampler, uv)</strong></td> <td>深度纹理采样</td> <td><code class="language-plaintext highlighter-rouge">SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, sampler_CameraDepthTexture, i.uv);</code></td> </tr> </tbody> </table> <hr/> <h3 id="衍生指令需要30"><strong>衍生指令（需要3.0+）</strong></h3> <table> <thead> <tr> <th>函数</th> <th>说明</th> <th>用途</th> <th>示例</th> </tr> </thead> <tbody> <tr> <td><strong>ddx(x)</strong></td> <td>x对屏幕X的偏导</td> <td>计算变化率</td> <td><code class="language-plaintext highlighter-rouge">float dUdx = ddx(i.uv.x);</code></td> </tr> <tr> <td><strong>ddy(y)</strong></td> <td>y对屏幕Y的偏导</td> <td>计算变化率</td> <td><code class="language-plaintext highlighter-rouge">float dUdy = ddy(i.uv.y);</code></td> </tr> <tr> <td><strong>fwidth(x)</strong></td> <td>abs(ddx(x)) + abs(ddy(x))</td> <td>边缘检测</td> <td><code class="language-plaintext highlighter-rouge">float edge = fwidth(i.uv);</code></td> </tr> </tbody> </table> <hr/> <h2 id="七数学函数速查表">七、数学函数速查表</h2> <h3 id="常用数学函数"><strong>常用数学函数</strong></h3> <table> <thead> <tr> <th>函数</th> <th>说明</th> <th>范围</th> <th>示例</th> </tr> </thead> <tbody> <tr> <td><strong>dot(a, b)</strong></td> <td>点积</td> <td>[-1, 1]（归一化向量）</td> <td><code class="language-plaintext highlighter-rouge">float ndotl = dot(normal, lightDir);</code></td> </tr> <tr> <td><strong>cross(a, b)</strong></td> <td>叉积</td> <td>垂直向量</td> <td><code class="language-plaintext highlighter-rouge">float3 binormal = cross(normal, tangent);</code></td> </tr> <tr> <td><strong>normalize(v)</strong></td> <td>归一化</td> <td>长度=1</td> <td><code class="language-plaintext highlighter-rouge">float3 normal = normalize(i.worldNormal);</code></td> </tr> <tr> <td><strong>length(v)</strong></td> <td>向量长度</td> <td>&gt;= 0</td> <td><code class="language-plaintext highlighter-rouge">float dist = length(worldPos - _WorldSpaceCameraPos);</code></td> </tr> <tr> <td><strong>distance(a, b)</strong></td> <td>两点距离</td> <td>&gt;= 0</td> <td><code class="language-plaintext highlighter-rouge">float dist = distance(worldPos, lightPos);</code></td> </tr> <tr> <td><strong>reflect(i, n)</strong></td> <td>反射向量</td> <td>-</td> <td><code class="language-plaintext highlighter-rouge">float3 reflectDir = reflect(-viewDir, normal);</code></td> </tr> <tr> <td><strong>refract(i, n, eta)</strong></td> <td>折射向量</td> <td>-</td> <td><code class="language-plaintext highlighter-rouge">float3 refractDir = refract(-viewDir, normal, 1.0/1.33);</code></td> </tr> <tr> <td><strong>lerp(a, b, t)</strong></td> <td>线性插值</td> <td>-</td> <td><code class="language-plaintext highlighter-rouge">fixed3 color = lerp(shadowColor, litColor, ndotl);</code></td> </tr> <tr> <td><strong>smoothstep(min, max, x)</strong></td> <td>平滑插值</td> <td>[0, 1]</td> <td><code class="language-plaintext highlighter-rouge">float smooth = smoothstep(0.4, 0.6, ndotl);</code></td> </tr> <tr> <td><strong>step(edge, x)</strong></td> <td>阶梯函数</td> <td>0或1</td> <td><code class="language-plaintext highlighter-rouge">float toon = step(0.5, ndotl);</code></td> </tr> <tr> <td><strong>saturate(x)</strong></td> <td>限制到[0,1]</td> <td>[0, 1]</td> <td><code class="language-plaintext highlighter-rouge">float val = saturate(ndotl);</code></td> </tr> <tr> <td><strong>clamp(x, min, max)</strong></td> <td>限制范围</td> <td>[min, max]</td> <td><code class="language-plaintext highlighter-rouge">float val = clamp(ndotl, 0.2, 0.8);</code></td> </tr> <tr> <td><strong>pow(x, y)</strong></td> <td>x的y次方</td> <td>-</td> <td><code class="language-plaintext highlighter-rouge">float spec = pow(ndoth, _Gloss);</code></td> </tr> <tr> <td><strong>exp(x)</strong></td> <td>e^x</td> <td>-</td> <td><code class="language-plaintext highlighter-rouge">float fog = exp(-depth * density);</code></td> </tr> <tr> <td><strong>log(x)</strong></td> <td>ln(x)</td> <td>-</td> <td>-</td> </tr> <tr> <td><strong>sqrt(x)</strong></td> <td>平方根</td> <td>-</td> <td><code class="language-plaintext highlighter-rouge">float dist = sqrt(x*x + y*y);</code></td> </tr> <tr> <td><strong>abs(x)</strong></td> <td>绝对值</td> <td>&gt;= 0</td> <td><code class="language-plaintext highlighter-rouge">float val = abs(x);</code></td> </tr> <tr> <td><strong>sign(x)</strong></td> <td>符号</td> <td>-1, 0, 1</td> <td><code class="language-plaintext highlighter-rouge">float s = sign(x);</code></td> </tr> <tr> <td><strong>floor(x)</strong></td> <td>向下取整</td> <td>-</td> <td><code class="language-plaintext highlighter-rouge">float stepped = floor(x * 5) / 5;</code></td> </tr> <tr> <td><strong>ceil(x)</strong></td> <td>向上取整</td> <td>-</td> <td><code class="language-plaintext highlighter-rouge">float stepped = ceil(x * 5) / 5;</code></td> </tr> <tr> <td><strong>frac(x)</strong></td> <td>小数部分</td> <td>[0, 1)</td> <td><code class="language-plaintext highlighter-rouge">float f = frac(x);</code></td> </tr> <tr> <td><strong>fmod(x, y)</strong></td> <td>x % y</td> <td>-</td> <td><code class="language-plaintext highlighter-rouge">float m = fmod(x, 2.0);</code></td> </tr> </tbody> </table> <hr/> <h3 id="三角函数"><strong>三角函数</strong></h3> <table> <thead> <tr> <th>函数</th> <th>说明</th> <th>输入单位</th> <th>范围</th> </tr> </thead> <tbody> <tr> <td><strong>sin(x)</strong></td> <td>正弦</td> <td>弧度</td> <td>[-1, 1]</td> </tr> <tr> <td><strong>cos(x)</strong></td> <td>余弦</td> <td>弧度</td> <td>[-1, 1]</td> </tr> <tr> <td><strong>tan(x)</strong></td> <td>正切</td> <td>弧度</td> <td>(-∞, +∞)</td> </tr> <tr> <td><strong>asin(x)</strong></td> <td>反正弦</td> <td>-</td> <td>[-π/2, π/2]</td> </tr> <tr> <td><strong>acos(x)</strong></td> <td>反余弦</td> <td>-</td> <td>[0, π]</td> </tr> <tr> <td><strong>atan(x)</strong></td> <td>反正切</td> <td>-</td> <td>[-π/2, π/2]</td> </tr> <tr> <td><strong>atan2(y, x)</strong></td> <td>两参数反正切</td> <td>-</td> <td>[-π, π]</td> </tr> </tbody> </table> <hr/> <h2 id="八语义semantics速查表">八、语义（Semantics）速查表</h2> <h3 id="顶点着色器输入语义"><strong>顶点着色器输入语义</strong></h3> <table> <thead> <tr> <th>语义</th> <th>类型</th> <th>说明</th> <th>来源</th> </tr> </thead> <tbody> <tr> <td><strong>POSITION</strong></td> <td>float4</td> <td>顶点位置（模型空间）</td> <td>Mesh</td> </tr> <tr> <td><strong>NORMAL</strong></td> <td>float3</td> <td>法线（模型空间）</td> <td>Mesh</td> </tr> <tr> <td><strong>TANGENT</strong></td> <td>float4</td> <td>切线（模型空间，w=±1）</td> <td>Mesh</td> </tr> <tr> <td><strong>TEXCOORD0-7</strong></td> <td>float2/4</td> <td>UV坐标</td> <td>Mesh</td> </tr> <tr> <td><strong>COLOR</strong></td> <td>fixed4</td> <td>顶点颜色</td> <td>Mesh</td> </tr> <tr> <td><strong>SV_VertexID</strong></td> <td>uint</td> <td>顶点索引</td> <td>系统自动</td> </tr> <tr> <td><strong>SV_InstanceID</strong></td> <td>uint</td> <td>实例索引（GPU Instancing）</td> <td>系统自动</td> </tr> </tbody> </table> <hr/> <h3 id="顶点着色器输出片元着色器输入语义"><strong>顶点着色器输出/片元着色器输入语义</strong></h3> <table> <thead> <tr> <th>语义</th> <th>类型</th> <th>说明</th> <th>必须</th> </tr> </thead> <tbody> <tr> <td><strong>SV_POSITION</strong></td> <td>float4</td> <td>裁剪空间位置</td> <td>✅必须</td> </tr> <tr> <td><strong>TEXCOORD0-9</strong></td> <td>float1-4</td> <td>任意插值数据</td> <td>可选</td> </tr> <tr> <td><strong>COLOR0-1</strong></td> <td>fixed4</td> <td>颜色数据</td> <td>可选</td> </tr> <tr> <td><strong>SV_IsFrontFace</strong></td> <td>bool</td> <td>是否正面（片元输入）</td> <td>可选</td> </tr> </tbody> </table> <p><strong>完整的顶点输入语义列表：</strong></p> <table> <thead> <tr> <th>语义</th> <th>含义</th> <th>数据类型</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">POSITION</code></td> <td>顶点位置（模型空间）</td> <td>float4</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">NORMAL</code></td> <td>法线（模型空间）</td> <td>float3</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">TANGENT</code></td> <td>切线（模型空间）</td> <td>float4</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">TEXCOORD0</code></td> <td>第一套UV</td> <td>float2/float4</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">TEXCOORD1</code></td> <td>第二套UV（光照贴图）</td> <td>float2/float4</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">TEXCOORD2</code></td> <td>第三套UV</td> <td>float2/float4</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">TEXCOORD3</code></td> <td>第四套UV</td> <td>float2/float4</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">COLOR</code></td> <td>顶点颜色</td> <td>float4</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_VertexID</code></td> <td>顶点ID</td> <td>uint</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_InstanceID</code></td> <td>实例ID（GPU Instancing）</td> <td>uint</td> </tr> </tbody> </table> <hr/> <h3 id="片元着色器输出语义"><strong>片元着色器输出语义</strong></h3> <table> <thead> <tr> <th>语义</th> <th>类型</th> <th>说明</th> <th>用途</th> </tr> </thead> <tbody> <tr> <td><strong>SV_Target</strong></td> <td>fixed4</td> <td>渲染目标0</td> <td>输出颜色（单目标）</td> </tr> <tr> <td><strong>SV_Target0-7</strong></td> <td>fixed4</td> <td>渲染目标0-7</td> <td>MRT（多目标）</td> </tr> <tr> <td><strong>SV_Depth</strong></td> <td>float</td> <td>自定义深度</td> <td>深度输出</td> </tr> </tbody> </table> <h3 id="常用系统值语义"><strong>常用系统值语义</strong></h3> <table> <thead> <tr> <th>语义</th> <th>使用位置</th> <th>含义</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">SV_POSITION</code></td> <td>顶点输出</td> <td>裁剪空间位置</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_Target</code></td> <td>片元输出</td> <td>渲染目标</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_Depth</code></td> <td>片元输出</td> <td>深度值</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_VertexID</code></td> <td>顶点输入</td> <td>顶点索引</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_InstanceID</code></td> <td>顶点输入</td> <td>实例索引</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_PrimitiveID</code></td> <td>几何/片元输入</td> <td>图元ID</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_IsFrontFace</code></td> <td>片元输入</td> <td>是否正面</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">SV_RenderTargetArrayIndex</code></td> <td>几何输出</td> <td>渲染目标数组索引</td> </tr> </tbody> </table> <p><strong>示例1：SV_VertexID（顶点ID）</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">appdata</span>
<span class="p">{</span>
    <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">vertexID</span> <span class="o">:</span> <span class="n">SV_VertexID</span><span class="p">;</span>  <span class="c1">// 顶点索引</span>
<span class="p">};</span>

<span class="n">v2f</span> <span class="nf">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    
    <span class="c1">// 使用顶点ID生成渐变色</span>
    <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">v</span><span class="p">.</span><span class="n">vertexID</span> <span class="o">/</span> <span class="mi">100</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>示例2：SV_IsFrontFace（正反面检测）</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="n">fixed4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">,</span> <span class="n">bool</span> <span class="n">isFrontFace</span> <span class="o">:</span> <span class="n">SV_IsFrontFace</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
<span class="p">{</span>
    <span class="c1">// 正面显示红色，背面显示蓝色</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isFrontFace</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 红色</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="nf">fixed4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 蓝色</span>
<span class="err">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>示例3：SV_PrimitiveID（三角形ID）</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="n">fixed4</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">,</span> <span class="n">uint</span> <span class="n">primitiveID</span> <span class="o">:</span> <span class="n">SV_PrimitiveID</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
<span class="p">{</span>
    <span class="c1">// 每个三角形不同颜色</span>
    <span class="kt">float</span> <span class="n">hue</span> <span class="o">=</span> <span class="n">frac</span><span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">primitiveID</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">618</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">fixed4</span><span class="p">(</span><span class="n">hue</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="n">hue</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="err">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>示例4：SV_Depth（自定义深度）</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">fragOutput</span>
<span class="p">{</span>
    <span class="n">fixed4</span> <span class="n">color</span> <span class="o">:</span> <span class="n">SV_Target</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">depth</span> <span class="o">:</span> <span class="n">SV_Depth</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">fragOutput</span> <span class="nf">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">fragOutput</span> <span class="n">o</span><span class="p">;</span>
    
    <span class="n">o</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
    
    <span class="c1">// 强制深度为0.5（总在中间）</span>
    <span class="n">o</span><span class="p">.</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <hr/> <h2 id="九渲染状态关键字表">九、渲染状态关键字表</h2> <h3 id="剔除模式"><strong>剔除模式</strong></h3> <table> <thead> <tr> <th>关键字</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><strong>Cull Back</strong></td> <td>剔除背面（默认）</td> </tr> <tr> <td><strong>Cull Front</strong></td> <td>剔除正面</td> </tr> <tr> <td><strong>Cull Off</strong></td> <td>双面渲染</td> </tr> </tbody> </table> <h3 id="深度测试"><strong>深度测试</strong></h3> <table> <thead> <tr> <th>关键字</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><strong>ZTest Less</strong></td> <td>深度小于通过（默认）</td> </tr> <tr> <td><strong>ZTest LEqual</strong></td> <td>深度小于等于通过</td> </tr> <tr> <td><strong>ZTest Greater</strong></td> <td>深度大于通过</td> </tr> <tr> <td><strong>ZTest GEqual</strong></td> <td>深度大于等于通过</td> </tr> <tr> <td><strong>ZTest Equal</strong></td> <td>深度等于通过</td> </tr> <tr> <td><strong>ZTest NotEqual</strong></td> <td>深度不等于通过</td> </tr> <tr> <td><strong>ZTest Always</strong></td> <td>总是通过</td> </tr> <tr> <td><strong>ZTest Never</strong></td> <td>总不通过</td> </tr> </tbody> </table> <h3 id="深度写入"><strong>深度写入</strong></h3> <table> <thead> <tr> <th>关键字</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td><strong>ZWrite On</strong></td> <td>写入深度（默认）</td> </tr> <tr> <td><strong>ZWrite Off</strong></td> <td>不写入深度（透明物体）</td> </tr> </tbody> </table> <h3 id="混合模式"><strong>混合模式</strong></h3> <table> <thead> <tr> <th>关键字</th> <th>效果</th> <th>用途</th> </tr> </thead> <tbody> <tr> <td><strong>Blend Off</strong></td> <td>无混合（默认）</td> <td>不透明物体</td> </tr> <tr> <td><strong>Blend SrcAlpha OneMinusSrcAlpha</strong></td> <td>标准透明</td> <td>透明物体</td> </tr> <tr> <td><strong>Blend One One</strong></td> <td>加法混合</td> <td>发光、粒子</td> </tr> <tr> <td><strong>Blend OneMinusDstColor One</strong></td> <td>柔和叠加</td> <td>特效</td> </tr> <tr> <td><strong>Blend DstColor Zero</strong></td> <td>乘法混合</td> <td>阴影、滤镜</td> </tr> </tbody> </table> <h1 id="shader基本模板">Shader基本模板</h1> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
</pre></td><td class="rouge-code"><pre><span class="n">Shader</span> <span class="s">"Tutorial/CompleteReference"</span>
<span class="p">{</span>
    <span class="n">Properties</span>
    <span class="p">{</span>
        <span class="n">_MainTex</span> <span class="p">(</span><span class="s">"Albedo"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"white"</span> <span class="p">{}</span>
        <span class="n">_Color</span> <span class="p">(</span><span class="s">"Color"</span><span class="p">,</span> <span class="n">Color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="n">SubShader</span>
    <span class="p">{</span>
        <span class="n">Tags</span> <span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="p">}</span>
        <span class="n">LOD</span> <span class="mi">100</span>
        
        <span class="n">Pass</span>
        <span class="p">{</span>
            <span class="n">Tags</span> <span class="p">{</span> <span class="s">"LightMode"</span><span class="o">=</span><span class="s">"ForwardBase"</span> <span class="p">}</span>
            
            <span class="n">Cull</span> <span class="n">Back</span>       <span class="c1">// 剔除背面</span>
            <span class="n">ZWrite</span> <span class="n">On</span>       <span class="c1">// 写入深度</span>
            <span class="n">ZTest</span> <span class="n">LEqual</span>    <span class="c1">// 深度测试</span>
            
            <span class="n">CGPROGRAM</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>            <span class="cp">#pragma multi_compile_fwdbase
</span>            <span class="cp">#pragma target 3.0
</span>            
            <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp">
</span>            <span class="cp">#include</span> <span class="cpf">"Lighting.cginc"</span><span class="cp">
</span>            
            <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
            <span class="n">float4</span> <span class="n">_MainTex_ST</span><span class="p">;</span>
            <span class="n">fixed4</span> <span class="n">_Color</span><span class="p">;</span>
            
            <span class="c1">// ===========================================</span>
            <span class="c1">// 顶点着色器输入</span>
            <span class="c1">// ===========================================</span>
            <span class="k">struct</span> <span class="n">appdata</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>     <span class="c1">// 模型空间位置</span>
                <span class="n">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>       <span class="c1">// 模型空间法线</span>
                <span class="n">float4</span> <span class="n">tangent</span> <span class="o">:</span> <span class="n">TANGENT</span><span class="p">;</span>     <span class="c1">// 模型空间切线</span>
                <span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>        <span class="c1">// UV0</span>
                <span class="n">float2</span> <span class="n">uv2</span> <span class="o">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>       <span class="c1">// UV1（光照贴图）</span>
                <span class="n">fixed4</span> <span class="n">color</span> <span class="o">:</span> <span class="n">COLOR</span><span class="p">;</span>         <span class="c1">// 顶点颜色</span>
            <span class="p">};</span>
            
            <span class="c1">// ===========================================</span>
            <span class="c1">// 顶点到片元</span>
            <span class="c1">// ===========================================</span>
            <span class="k">struct</span> <span class="n">v2f</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>     <span class="c1">// 裁剪空间位置（必须）</span>
                <span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>        <span class="c1">// UV</span>
                <span class="n">float3</span> <span class="n">worldPos</span> <span class="o">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>  <span class="c1">// 世界空间位置</span>
                <span class="n">float3</span> <span class="n">worldNormal</span> <span class="o">:</span> <span class="n">TEXCOORD2</span><span class="p">;</span> <span class="c1">// 世界空间法线</span>
                <span class="n">float3</span> <span class="n">worldTangent</span> <span class="o">:</span> <span class="n">TEXCOORD3</span><span class="p">;</span> <span class="c1">// 世界空间切线</span>
                <span class="n">float3</span> <span class="n">worldBinormal</span> <span class="o">:</span> <span class="n">TEXCOORD4</span><span class="p">;</span> <span class="c1">// 世界空间副法线</span>
            <span class="p">};</span>
            
            <span class="c1">// ===========================================</span>
            <span class="c1">// 顶点着色器</span>
            <span class="c1">// ===========================================</span>
            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                
                <span class="c1">// 位置变换</span>
                <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>           <span class="c1">// 模型→裁剪</span>
                <span class="n">o</span><span class="p">.</span><span class="n">worldPos</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">).</span><span class="n">xyz</span><span class="p">;</span> <span class="c1">// 模型→世界</span>
                
                <span class="c1">// 法线变换</span>
                <span class="n">o</span><span class="p">.</span><span class="n">worldNormal</span> <span class="o">=</span> <span class="n">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">worldTangent</span> <span class="o">=</span> <span class="n">UnityObjectToWorldDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">worldBinormal</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">worldNormal</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">worldTangent</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
                
                <span class="c1">// UV变换</span>
                <span class="n">o</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
                
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="c1">// ===========================================</span>
            <span class="c1">// 片元着色器</span>
            <span class="c1">// ===========================================</span>
            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
            <span class="p">{</span>
                <span class="c1">// 归一化插值后的向量</span>
                <span class="n">float3</span> <span class="n">worldNormal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldNormal</span><span class="p">);</span>
                
                <span class="c1">// 光照方向（世界空间）</span>
                <span class="n">float3</span> <span class="n">worldLightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">UnityWorldSpaceLightDir</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">));</span>
                
                <span class="c1">// 视线方向（世界空间）</span>
                <span class="n">float3</span> <span class="n">worldViewDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">UnityWorldSpaceViewDir</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">));</span>
                
                <span class="c1">// 漫反射</span>
                <span class="kt">float</span> <span class="n">ndotl</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">worldNormal</span><span class="p">,</span> <span class="n">worldLightDir</span><span class="p">));</span>
                
                <span class="c1">// 采样纹理</span>
                <span class="n">fixed4</span> <span class="n">albedo</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">)</span> <span class="o">*</span> <span class="n">_Color</span><span class="p">;</span>
                
                <span class="c1">// 最终颜色</span>
                <span class="n">fixed3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">albedo</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">ndotl</span><span class="p">;</span>
                <span class="n">fixed3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">UNITY_LIGHTMODEL_AMBIENT</span><span class="p">.</span><span class="n">xyz</span> <span class="o">*</span> <span class="n">albedo</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
                
                <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">ambient</span> <span class="o">+</span> <span class="n">diffuse</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">FallBack</span> <span class="s">"Diffuse"</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>]]></content><author><name></name></author><category term="TAMonth01"/><category term="shader"/><category term="rendering"/><category term="unity"/><summary type="html"><![CDATA[Unity函数常用速查]]></summary></entry><entry><title type="html">Lv.2 Unity主线： 添加阴影</title><link href="https://xueqingzhe.github.io/blog/2025/Lv.2-Unity%E4%B8%BB%E7%BA%BF-%E6%B7%BB%E5%8A%A0%E9%98%B4%E5%BD%B1/" rel="alternate" type="text/html" title="Lv.2 Unity主线： 添加阴影"/><published>2025-12-21T00:00:00+00:00</published><updated>2025-12-21T00:00:00+00:00</updated><id>https://xueqingzhe.github.io/blog/2025/Lv.2%20Unity%E4%B8%BB%E7%BA%BF%EF%BC%9A%20%E6%B7%BB%E5%8A%A0%E9%98%B4%E5%BD%B1</id><content type="html" xml:base="https://xueqingzhe.github.io/blog/2025/Lv.2-Unity%E4%B8%BB%E7%BA%BF-%E6%B7%BB%E5%8A%A0%E9%98%B4%E5%BD%B1/"><![CDATA[<h1 id="阴影的必要代码">阴影的必要代码</h1> <h2 id="passtag">PassTag</h2> <p><strong><em>需要声明前向渲染ForwardBase，这是声明给程序端C++看的</em></strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">Tags</span><span class="p">{</span>
      <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ForwardBase"</span>
    <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="pragma指令">pragma指令</h2> <p><strong><em>编译变体fwdbase，也就多次编译不同的Shdaer版本，这里是声明构成前向渲染专用变体，这和Tags的声明不同，它是给Shdaer编译器看的</em></strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="cp">#pragma multi_compile_fwdbase
</span></pre></td></tr></tbody></table></code></pre></div></div> <h2 id="include文件">Include文件</h2> <p><strong><em>只需要阴影的话Lighting可以不引入也行，不过都写上就完了</em></strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp">
#include</span> <span class="cpf">"Lighting.cginc"</span><span class="cp">
</span><span class="c1">// 阴影宏定义在这里</span>
<span class="cp">#include</span> <span class="cpf">"AutoLight.cginc"</span><span class="c1">             </span><span class="cp">
</span></pre></td></tr></tbody></table></code></pre></div></div> <h2 id="appdata结构体声明要求">appdata结构体声明要求</h2> <p><strong><em>之前写的物体空间的顶点posOS必须换成vertex。原因在下面将</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251210192805.png" alt="图片"/></p> <h2 id="v2f结构体声明要求">v2f结构体声明要求</h2> <p><strong><em>这里在结构体中声明阴影数据，注意括号中的顺序号</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251208225718.png" alt="图片"/></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
<span class="o">----</span>
<span class="c1">// 阴影坐标声明（自动处理多个变体）</span>
<span class="n">UNITY_SHADOW_COORDS</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong><em>这里需要额外说明一点，裁剪空间下的顶点位置，必须命名为pos.同时这也是这是物体空间的顶点posOS必须换成vertex的原因。AutoLight.cginc文件下Unity阴影函数里面固定的，其他名称会报错</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251210193016.png" alt="图片"/></p> <h2 id="顶点着色器">顶点着色器</h2> <p><strong><em>阴影数据处理，直接系统函数</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251208230152.png" alt="图片"/></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="c1">//传输阴影数据（关键！）</span>
<span class="n">TRANSFER_SHADOW</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="片元着色器">片元着色器</h2> <p><strong><em>计算阴影衰减，输出结果和diffuse乘法计算就行，注意不要和环境光相乘</em></strong> <strong>这里需要说明一点，阴影在Shader中分为两个内容，一个是接收其它的阴影，一个是投射自己的阴影</strong> <img src="/assets/img/TAMonth01/Pasted image 20251208230218.png" alt="图片"/></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="err"> </span><span class="c1">// 计算阴影衰减（自动处理所有阴影类型）</span>
<span class="n">fixed</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">SHADOW_ATTENUATION</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="投射阴影pass">投射阴影Pass</h2> <p><strong><em>基本上是固定写法，如果是半透明裁剪一类的，需要自己做裁剪</em></strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre><span class="n">Pass</span>
        <span class="p">{</span>
            <span class="n">Name</span><span class="s">"ShadowCaster"</span>
            <span class="n">Tags</span><span class="p">{</span>
                <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ShadowCaster"</span>
            <span class="p">}</span>
             <span class="n">CGPROGRAM</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>            
            <span class="c1">// 阴影投射需要的变体</span>
            <span class="cp">#pragma multi_compile_shadowcaster
</span>            
            <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp">
</span>            
            <span class="k">struct</span> <span class="n">appdata</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>
            <span class="p">};</span>
            
            <span class="k">struct</span> <span class="n">v2f</span>
            <span class="p">{</span>
                <span class="n">V2F_SHADOW_CASTER</span><span class="p">;</span>  <span class="c1">// Unity预定义的结构</span>
            <span class="p">};</span>
            
            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="n">TRANSFER_SHADOW_CASTER_NORMALOFFSET</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>  <span class="c1">// 转换到阴影空间</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
            <span class="p">{</span>
                <span class="c1">//裁剪处理位置clip（）</span>
                <span class="n">SHADOW_CASTER_FRAGMENT</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1">// 写入阴影深度</span>
            <span class="p">}</span>
            <span class="n">ENDCG</span>
        <span class="p">}</span>
      
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>如果不想写这个Pass，可以直接在末尾加上 FallBack “Diffuse”，但是没有自己写性能好</strong> <img src="/assets/img/TAMonth01/Pasted image 20251208232844.png" alt="图片"/></p> <h1 id="代码参考">代码参考</h1> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
</pre></td><td class="rouge-code"><pre><span class="n">Shader</span> <span class="s">"Unlit/AddShadow"</span>
<span class="p">{</span>
    <span class="n">Properties</span>
    <span class="p">{</span>
        <span class="n">_MainTex</span> <span class="p">(</span><span class="s">"Texture"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"white"</span> <span class="p">{}</span>
    <span class="p">}</span>
    <span class="n">SubShader</span>
    <span class="p">{</span>
        <span class="n">Tags</span> <span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="p">}</span>
        <span class="n">LOD</span> <span class="mi">100</span>

        <span class="n">Pass</span>
        <span class="p">{</span>
           <span class="n">Name</span> <span class="s">"Forward"</span>
           <span class="n">Tags</span><span class="p">{</span>
            <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ForwardBase"</span>
           <span class="p">}</span>
            <span class="n">CGPROGRAM</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>            <span class="c1">// make fog work</span>
            
            <span class="cp">#pragma multi_compile_fwdbase
</span>
            <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp">
</span>            <span class="cp">#include</span> <span class="cpf">"Lighting.cginc"</span><span class="cp">
</span>            <span class="cp">#include</span> <span class="cpf">"AutoLight.cginc"</span><span class="c1">             // 1.阴影宏定义在这里</span><span class="cp">
</span>
            <span class="k">struct</span> <span class="n">appdata</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">posOS</span>     <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
                <span class="n">float2</span> <span class="n">uv</span>        <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">normalOS</span>  <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>
                <span class="n">float4</span> <span class="n">tangentOS</span> <span class="o">:</span> <span class="n">TANGENT</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="n">v2f</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
                <span class="n">float2</span> <span class="n">texcoord</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">posWS</span> <span class="o">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">normalWS</span> <span class="o">:</span><span class="n">TEXCOORD2</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">tangentWS</span><span class="o">:</span> <span class="n">TEXCOORD3</span><span class="p">;</span>
                <span class="c1">// 阴影坐标声明（自动处理多个变体）</span>
                <span class="n">UNITY_SHADOW_COORDS</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> 
            <span class="p">};</span>

            <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
            <span class="n">float4</span> <span class="n">_MainTex_ST</span><span class="p">;</span>

            <span class="n">v2f</span> <span class="n">vert</span> <span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">posOS</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">texcoord</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">posWS</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">posOS</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">normalWS</span> <span class="o">=</span> <span class="n">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normalOS</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">tangentWS</span> <span class="o">=</span> <span class="n">UnityObjectToWorldDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tangentOS</span><span class="p">);</span>
                <span class="c1">// 传输阴影数据（关键！）</span>
                <span class="n">TRANSFER_SHADOW</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">fixed4</span> <span class="n">frag</span> <span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
            <span class="p">{</span>
                <span class="c1">// sample the texture</span>
                <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span>

                <span class="c1">// 计算阴影衰减（自动处理所有阴影类型）</span>
                <span class="n">fixed</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">SHADOW_ATTENUATION</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

                <span class="k">return</span> <span class="n">col</span> <span class="o">*</span><span class="n">shadow</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">ENDCG</span>
        <span class="p">}</span>
        <span class="n">Pass</span>
        <span class="p">{</span>
            <span class="n">Name</span><span class="s">"ShadowCaster"</span>
            <span class="n">Tags</span><span class="p">{</span>
                <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ShadowCaster"</span>
            <span class="p">}</span>
             <span class="n">CGPROGRAM</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>            
            <span class="c1">// 阴影投射需要的变体</span>
            <span class="cp">#pragma multi_compile_shadowcaster
</span>            
            <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp">
</span>            
            <span class="k">struct</span> <span class="n">appdata</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>
            <span class="p">};</span>
            
            <span class="k">struct</span> <span class="n">v2f</span>
            <span class="p">{</span>
                <span class="n">V2F_SHADOW_CASTER</span><span class="p">;</span>  <span class="c1">// Unity预定义的结构</span>
            <span class="p">};</span>
            
            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="n">TRANSFER_SHADOW_CASTER_NORMALOFFSET</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>  <span class="c1">// 转换到阴影空间</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>
            
            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
            <span class="p">{</span>
                <span class="n">SHADOW_CASTER_FRAGMENT</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1">// 写入阴影深度</span>
            <span class="p">}</span>
            <span class="n">ENDCG</span>
        <span class="p">}</span>
        
    <span class="p">}</span>
    <span class="n">FallBack</span> <span class="s">"Diffuse"</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>]]></content><author><name></name></author><category term="TAMonth01"/><category term="shader"/><category term="rendering"/><category term="unity"/><summary type="html"><![CDATA[如何添加阴影]]></summary></entry><entry><title type="html">Lv.2 Unity主线：添加法线</title><link href="https://xueqingzhe.github.io/blog/2025/Lv.2-Unity%E4%B8%BB%E7%BA%BF-%E6%B7%BB%E5%8A%A0%E6%B3%95%E7%BA%BF/" rel="alternate" type="text/html" title="Lv.2 Unity主线：添加法线"/><published>2025-12-21T00:00:00+00:00</published><updated>2025-12-21T00:00:00+00:00</updated><id>https://xueqingzhe.github.io/blog/2025/Lv.2%20Unity%E4%B8%BB%E7%BA%BF%EF%BC%9A%E6%B7%BB%E5%8A%A0%E6%B3%95%E7%BA%BF</id><content type="html" xml:base="https://xueqingzhe.github.io/blog/2025/Lv.2-Unity%E4%B8%BB%E7%BA%BF-%E6%B7%BB%E5%8A%A0%E6%B3%95%E7%BA%BF/"><![CDATA[<h1 id="法线贴图">法线贴图</h1> <p><strong>通常模型都会有法线贴图，里面是关于模型法线的信息，对法线的处理需要在计算光照之前</strong> <img src="/assets/img/TAMonth01/Pasted image 20251222210754.png" alt="图片"/></p> <h1 id="添加法线贴图">添加法线贴图</h1> <h2 id="properties">properties</h2> <p><strong>一个是采样器，一个是法线强度的控制</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="n">_NormalMap</span><span class="p">(</span><span class="s">"NormalMap"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"bump"</span><span class="p">{}</span>
<span class="n">_NormalMapScale</span><span class="p">(</span><span class="s">"NormalMapScale"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
<span class="o">----------</span>
<span class="n">sampler2D</span> <span class="n">_NormalMap</span><span class="p">;</span>
<span class="n">half</span> <span class="n">_NormalMapScale</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="appdata">appdata</h2> <p><strong>appdata需要读取模型原始法线和切线</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">appdata</span>
<span class="p">{</span>
    <span class="n">float4</span> <span class="n">vertex</span>   <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">normal</span>   <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>   <span class="c1">//法线</span>
    <span class="n">float4</span> <span class="n">tangent</span>  <span class="o">:</span> <span class="n">TANGENT</span><span class="p">;</span>  <span class="c1">//切线</span>
    <span class="n">float2</span> <span class="n">uv</span>       <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>         
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="v2f">v2f</h2> <p><strong>v2f则需要接收处理的模型法线和切线以及副切线</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">v2f</span>
<span class="p">{</span>
    <span class="n">float4</span> <span class="n">pos</span>          <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">positionWS</span>   <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">normalWS</span>     <span class="o">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span> <span class="c1">//法线</span>
    <span class="n">float3</span> <span class="n">tangentWS</span>    <span class="o">:</span> <span class="n">TEXCOORD2</span><span class="p">;</span> <span class="c1">//切线</span>
    <span class="n">float3</span> <span class="n">bitangentWS</span>  <span class="o">:</span> <span class="n">TEXCOORD3</span><span class="p">;</span> <span class="c1">//副切线</span>
    <span class="n">float2</span> <span class="n">texcoord</span>     <span class="o">:</span> <span class="n">TEXCOORD4</span><span class="p">;</span>
    <span class="n">UNITY_SHADOW_COORDS</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="vert-顶点着色器">vert 顶点着色器</h2> <p><strong>处理数据参考</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="n">v2f</span> <span class="nf">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">positionWS</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">normalWS</span> <span class="o">=</span> <span class="n">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentWS</span> <span class="o">=</span> <span class="n">UnityObjectToWorldDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="c1">//* v.tangent.w处理平台差异</span>
    <span class="n">o</span><span class="p">.</span><span class="n">bitangentWS</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">normalWS</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">tangentWS</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">texcoord</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span><span class="n">_MainTex</span><span class="p">);</span>
    <span class="n">TRANSFER_SHADOW</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="frag片元着色器">frag片元着色器</h2> <h3 id="法线贴图混合">法线贴图混合</h3> <p><strong>对于法线贴图的混合，需要先构建TBN矩阵，其实就是把模型顶点法线，切线，副切线写成矩阵形式，注意需要归一化</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">float3x3</span> <span class="n">TBN</span> <span class="o">=</span> <span class="n">float3x3</span><span class="p">(</span><span class="n">tangentWS</span><span class="p">,</span> <span class="n">bitangentWS</span><span class="p">,</span> <span class="n">normalWS</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>采样法线贴图需要额外的UnpackNormal，对于强度控制只需要控制xy分量，也就是切线和副切线，因为切线和副切线决定面的倾斜程度，不对法线操作是因为在归一化后会间接影响，如果同时都乘上这个因子，那么归一化相当于和原法线强度不变</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">float3</span> <span class="n">normalMapData</span> <span class="o">=</span> <span class="n">UnpackNormal</span><span class="p">(</span><span class="n">tex2D</span><span class="p">(</span><span class="n">_NormalMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
<span class="n">normalMapData</span><span class="p">.</span><span class="n">xy</span> <span class="o">*=</span> <span class="n">_NormalMapScale</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>最后就是混合阶段，直接使用矩阵乘法就行</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">float3</span> <span class="n">pixelNormal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">normalMapData</span><span class="p">,</span> <span class="n">TBN</span><span class="p">));</span>
<span class="kt">float</span> <span class="n">noL</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">pixelNormal</span><span class="p">,</span> <span class="n">lightWS</span><span class="p">));</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>当然不构建矩阵乘法其实还有一种写法，实际是一样的</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">float3</span> <span class="n">pixelNormal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span> <span class="n">normalMapData</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">tangentWS</span> 
        <span class="o">+</span> <span class="n">normalMapData</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">bitangentWS</span> 
        <span class="o">+</span> <span class="n">normalMapData</span><span class="p">.</span><span class="n">z</span> <span class="o">*</span> <span class="n">normalWS</span> <span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h3 id="完整代码参考">完整代码参考</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="n">float4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
<span class="p">{</span>
 <span class="c1">//vectors</span>
 <span class="n">float3</span> <span class="n">positionWS</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">positionWS</span><span class="p">;</span> 
 <span class="n">float3</span> <span class="n">normalWS</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normalWS</span><span class="p">);</span>
 <span class="n">float3</span> <span class="n">tangentWS</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentWS</span><span class="p">);</span>
 <span class="n">float3</span> <span class="n">bitangentWS</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">bitangentWS</span><span class="p">);</span>
 <span class="n">float3x3</span> <span class="n">TBN</span> <span class="o">=</span> <span class="n">float3x3</span><span class="p">(</span><span class="n">tangentWS</span><span class="p">,</span> <span class="n">bitangentWS</span><span class="p">,</span> <span class="n">normalWS</span><span class="p">);</span>
 <span class="n">half3</span> <span class="n">lightWS</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
 <span class="n">float3</span> <span class="n">viewDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">positionWS</span><span class="p">);</span>
 <span class="c1">//tex</span>
 <span class="n">float3</span> <span class="n">lightColor</span> <span class="o">=</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
 <span class="n">float4</span> <span class="n">baseCol</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span>
 <span class="n">float3</span> <span class="n">normalMapData</span> <span class="o">=</span> <span class="n">UnpackNormal</span><span class="p">(</span><span class="n">tex2D</span><span class="p">(</span><span class="n">_NormalMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
 <span class="n">normalMapData</span><span class="p">.</span><span class="n">xy</span> <span class="o">*=</span> <span class="n">_NormalMapScale</span><span class="p">;</span>
 <span class="c1">//halfLambet</span>
 <span class="n">float3</span> <span class="n">pixelNormal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">normalMapData</span><span class="p">,</span> <span class="n">TBN</span><span class="p">));</span>
 <span class="kt">float</span> <span class="n">noL</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">pixelNormal</span><span class="p">,</span> <span class="n">lightWS</span><span class="p">));</span>
 <span class="kt">float</span> <span class="n">halfLambet</span> <span class="o">=</span> <span class="n">noL</span><span class="o">*</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
    
    <span class="c1">//Shadow</span>
    <span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">SHADOW_ATTENUATION</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">//output</span>
    <span class="n">float3</span> <span class="n">finalColor</span> <span class="o">=</span> <span class="n">baseCol</span> <span class="o">*</span><span class="n">halfLambet</span> <span class="o">*</span> <span class="n">lightColor</span> <span class="o">*</span><span class="n">shadow</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">float4</span><span class="p">(</span><span class="n">finalColor</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>]]></content><author><name></name></author><category term="TAMonth01"/><category term="shader"/><category term="rendering"/><category term="unity"/><summary type="html"><![CDATA[如何添加法线]]></summary></entry><entry><title type="html">镜面反射光照模型Phong和Blinn-Phong</title><link href="https://xueqingzhe.github.io/blog/2025/Lv.2-Unity%E4%B8%BB%E7%BA%BF-%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8BPhong%E5%92%8CBlinn-Phong/" rel="alternate" type="text/html" title="镜面反射光照模型Phong和Blinn-Phong"/><published>2025-12-21T00:00:00+00:00</published><updated>2025-12-21T00:00:00+00:00</updated><id>https://xueqingzhe.github.io/blog/2025/Lv.2%20Unity%E4%B8%BB%E7%BA%BF%EF%BC%9A%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8BPhong%E5%92%8CBlinn-Phong</id><content type="html" xml:base="https://xueqingzhe.github.io/blog/2025/Lv.2-Unity%E4%B8%BB%E7%BA%BF-%E9%95%9C%E9%9D%A2%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8BPhong%E5%92%8CBlinn-Phong/"><![CDATA[<h1 id="phong">Phong</h1> <p><strong>Phong(1975) - 最早的高光模型，也是BRDF的一种。这里需要说明一点，它不是基于物理的光照模型，而是经验模型，Blinn-Phong也是如此。</strong></p> <h2 id="核心原理及公式">核心原理及公式</h2> <p>Phong 模型基于<strong>完美镜面反射</strong>假设： <strong>完美镜面反射</strong>指的是：</p> <ol> <li><strong>表面完全光滑</strong>（理想化假设）</li> <li><strong>光线遵循反射定律</strong>：入射角 = 反射角</li> <li><strong>反射方向唯一确定</strong>：给定入射方向 L，反射方向 R 只有一个 <strong>理论上</strong>的完美镜面反射：只有 V = R 时才能看到高光 其他方向强度 = 0。 Phong 在反射上做了妥协，它允许控制高光的范围，也就是(R·V)^α中的α来控制宽度</li> </ol> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">Specular</span> <span class="o">=</span> <span class="n">Ks</span> <span class="err">×</span> <span class="p">(</span><span class="n">R</span> <span class="err">·</span> <span class="n">V</span><span class="p">)</span><span class="o">^</span><span class="err">α</span> <span class="err">×</span> <span class="n">LightColor</span>
</pre></td></tr></tbody></table></code></pre></div></div> <ul> <li><strong>Ks</strong>: 高光颜色/强度</li> <li><strong>R</strong>: 反射光方向</li> <li><strong>V</strong>: 视线方向</li> <li><strong>α</strong> (shininess): 高光锐利度</li> </ul> <p><strong>对于高光部分：</strong></p> <ul> <li>✅ 表面完全光滑</li> <li>✅ 完美镜面反射</li> <li>✅ 反射方向由反射定律确定</li> <li>❌ <strong>但允许反射有”宽度”</strong>（通过 shininess 控制） <strong><em>图片来自<a href="https://learnopengl.com/Lighting/Basic-Lighting">https://learnopengl.com/Lighting/Basic-Lighting</a></em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251221231221.png" alt="图片"/> 从图像上来看，当 V 与 R <strong>完全重合</strong>时，高光最强（R·V = 1），反之就会衰减，这里其实就是求反射向量R在相机向量V上的投影，也就是R·V作为权重来作为高光衰减范围，使用Shininess（α）作为幂来控制高光集中度，Shininess表示光泽度，Shininess越大表示物体越光滑，高光越集中衰减范围越小。</li> </ul> <h2 id="reflectdir计算">ReflectDir计算</h2> <p><strong>这里需要说明一点，此处光向量是物体指向光源，而非物理上的光源指向物体</strong> <strong>下方是手动计算方法</strong> <img src="/assets/img/TAMonth01/Screenshot_20251222_181642_Samsung capture.jpg" alt="图片"/> <strong>当然引擎中一般是带有这个函数的，所以可以使用自带函数</strong></p> <h1 id="blinn-phong">Blinn-Phong</h1> <p>1975年：Phong Bui Tuong 提出 Phong 模型 1977年：Jim Blinn 提出改进版 → Blinn-Phong</p> <h2 id="公式">公式</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">H</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="n">V</span><span class="p">)</span>
<span class="n">specular</span> <span class="o">=</span> <span class="n">Ks</span> <span class="err">×</span> <span class="p">(</span><span class="n">N</span><span class="err">·</span><span class="n">H</span><span class="p">)</span><span class="o">^</span><span class="err">α</span> <span class="err">×</span> <span class="n">LightColor</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="为什么有blinn-phong">为什么有Blinn-Phong</h2> <p><strong>问题 1：因为计算开销问题</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="c1">// Phong 需要计算反射向量</span>
<span class="n">float3</span> <span class="n">R</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>  <span class="c1">// 需要：R = 2(N·L)N - L</span>
<span class="kt">float</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">V</span><span class="p">),</span> <span class="n">shininess</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>问题 2：数值不稳定</strong></p> <div class="language-hlsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">float</span> <span class="n">RdotV</span> <span class="o">=</span> <span class="nb">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">V</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>当视角接近掠射角（Grazing angle）时</strong>：</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>    <span class="n">V</span> <span class="p">(</span><span class="err">几乎平行于表面</span><span class="p">)</span>
    <span class="err">↗</span>
   <span class="o">/</span>
  <span class="o">/</span><span class="n">_____</span> <span class="err">表面</span>
  <span class="err">↑</span> <span class="n">N</span>
  
<span class="n">R</span> <span class="err">和</span> <span class="n">V</span> <span class="err">的夹角可能</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="err">°</span>
<span class="err">→</span> <span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
<span class="err">→</span> <span class="err">需要</span> <span class="n">clamp</span><span class="err">，但会出现硬边（</span><span class="n">hard</span> <span class="n">edge</span><span class="err">）</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>问题 3：能量不守恒（后来发现）</strong></p> <p>Phong 模型在掠射角下能量分布不符合物理规律（这在 1977 年还不是主要关注点）。</p> <h2 id="blinn-phong-的核心创新">Blinn-Phong 的核心创新</h2> <p><strong>革命性思想：半程向量（Halfway Vector）</strong> <strong>Jim Blinn 的洞察</strong>： 与其计算 “R 是否接近 V” 不如计算 “N 是否接近 H” <strong>半程向量就是L+V，视角向量和光线向量相加</strong> <img src="/assets/img/TAMonth01/半程(角)向量.gif" alt="图片"/></p> <h2 id="phong-vs-blinn-phong-详细对比">Phong vs Blinn-Phong 详细对比</h2> <table> <thead> <tr> <th>特性</th> <th>Phong</th> <th>Blinn-Phong</th> </tr> </thead> <tbody> <tr> <td><strong>提出年份</strong></td> <td>1975</td> <td>1977</td> </tr> <tr> <td><strong>核心计算</strong></td> <td>R·V</td> <td>N·H</td> </tr> <tr> <td><strong>关键向量</strong></td> <td>反射向量 R</td> <td>半程向量 H</td> </tr> <tr> <td><strong>计算开销</strong></td> <td>较高（~8 ALU）</td> <td>较低（~6 ALU）</td> </tr> <tr> <td><strong>性能</strong></td> <td>基准</td> <td>快 20-30%</td> </tr> <tr> <td><strong>数值稳定性</strong></td> <td>较差（掠射角）</td> <td>较好</td> </tr> <tr> <td><strong>高光形状</strong></td> <td>稍大、柔和</td> <td>稍小、锐利</td> </tr> <tr> <td><strong>Shininess 对应</strong></td> <td>α</td> <td>~4α</td> </tr> <tr> <td><strong>现代引擎采用</strong></td> <td>较少</td> <td>广泛（Unity, UE 默认）</td> </tr> <tr> <td><strong>硬件友好</strong></td> <td>一般</td> <td>更好</td> </tr> </tbody> </table> <h1 id="unity代码参考">Unity代码参考</h1> <h2 id="properties">properties</h2> <p><strong>添加高光颜色，强度，光泽度控制</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="n">_SpecularColor</span><span class="p">(</span><span class="s">"SpecularColor"</span><span class="p">,</span><span class="n">color</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">_SpecularIntensity</span><span class="p">(</span><span class="s">"SpecularIntensity"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">50</span><span class="p">))</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">_SpecularShininess</span><span class="p">(</span><span class="s">"SpecularShininess"</span><span class="p">,</span> <span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span> <span class="o">=</span> <span class="mi">2</span>
<span class="o">----------</span>
<span class="n">half4</span> <span class="n">_SpecularColor</span><span class="p">;</span>
<span class="n">half</span> <span class="n">_SpecularIntensity</span><span class="p">;</span>
<span class="n">half</span> <span class="n">_SpecularShininess</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="appdata">appdata</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">appdata</span>
<span class="p">{</span>
    <span class="n">float4</span> <span class="n">vertex</span>   <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">normal</span>   <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>   <span class="c1">//法线</span>
    <span class="n">float4</span> <span class="n">tangent</span>  <span class="o">:</span> <span class="n">TANGENT</span><span class="p">;</span>  <span class="c1">//切线</span>
    <span class="n">float2</span> <span class="n">uv</span>       <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>         
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="v2f">v2f</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">v2f</span>
<span class="p">{</span>
    <span class="n">float4</span> <span class="n">pos</span>          <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">positionWS</span>   <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">normalWS</span>     <span class="o">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span> <span class="c1">//法线</span>
    <span class="n">float3</span> <span class="n">tangentWS</span>    <span class="o">:</span> <span class="n">TEXCOORD2</span><span class="p">;</span> <span class="c1">//切线</span>
    <span class="n">float3</span> <span class="n">bitangentWS</span>  <span class="o">:</span> <span class="n">TEXCOORD3</span><span class="p">;</span> <span class="c1">//副切线</span>
    <span class="n">float2</span> <span class="n">texcoord</span>     <span class="o">:</span> <span class="n">TEXCOORD4</span><span class="p">;</span>
    <span class="n">UNITY_SHADOW_COORDS</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="vert-顶点着色器">vert 顶点着色器</h2> <p><strong>处理数据参考</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="n">v2f</span> <span class="nf">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">positionWS</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">normalWS</span> <span class="o">=</span> <span class="n">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
    <span class="n">o</span><span class="p">.</span><span class="n">tangentWS</span> <span class="o">=</span> <span class="n">UnityObjectToWorldDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="c1">//* v.tangent.w处理平台差异</span>
    <span class="n">o</span><span class="p">.</span><span class="n">bitangentWS</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">o</span><span class="p">.</span><span class="n">normalWS</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">tangentWS</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
    <span class="n">o</span><span class="p">.</span><span class="n">texcoord</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span><span class="n">_MainTex</span><span class="p">);</span>
    <span class="n">TRANSFER_SHADOW</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="frag片元着色器">frag片元着色器</h2> <h3 id="关键代码">关键代码</h3> <p><strong>PhongSpecular，注意这里取的是光向量的反向，其它的套公式就行</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="c1">//Specular</span>
<span class="c1">//phong</span>
<span class="n">half3</span> <span class="n">reflectDir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">lightWS</span><span class="p">,</span> <span class="n">pixelNormal</span><span class="p">);</span>
<span class="n">half</span> <span class="n">phongItem</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">reflectDir</span><span class="p">,</span> <span class="n">viewDir</span><span class="p">));</span>
<span class="n">half3</span> <span class="n">phongSpecular</span> <span class="o">=</span> <span class="n">_SpecularColor</span><span class="p">.</span><span class="n">xyz</span> <span class="o">*</span> <span class="n">_SpecularIntensity</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">phongItem</span><span class="p">,</span> <span class="n">_SpecularShininess</span><span class="p">)</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>Blinn-phongSpecular，改为计算半程向量和NoH</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="c1">//Blinn-phong</span>
<span class="n">half3</span> <span class="n">halfDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightWS</span> <span class="o">+</span> <span class="n">viewDir</span><span class="p">);</span>
<span class="n">half</span> <span class="n">blinnPhongItem</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">pixelNormal</span><span class="p">,</span> <span class="n">halfDir</span><span class="p">));</span>
<span class="n">half3</span> <span class="n">blinnPhongSpecular</span> <span class="o">=</span> <span class="n">_SpecularColor</span><span class="p">.</span><span class="n">xyz</span> <span class="o">*</span> <span class="n">_SpecularIntensity</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">blinnPhongItem</span><span class="p">,</span> <span class="n">_SpecularShininess</span><span class="p">)</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h3 id="完整代码参考">完整代码参考</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre><span class="n">float4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
<span class="p">{</span>
 <span class="c1">//vectors</span>
 <span class="n">float3</span> <span class="n">positionWS</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">positionWS</span><span class="p">;</span> 
 <span class="n">float3</span> <span class="n">normalWS</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normalWS</span><span class="p">);</span>
 <span class="n">float3</span> <span class="n">tangentWS</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentWS</span><span class="p">);</span>
 <span class="n">float3</span> <span class="n">bitangentWS</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">bitangentWS</span><span class="p">);</span>
 <span class="n">float3x3</span> <span class="n">TBN</span> <span class="o">=</span> <span class="n">float3x3</span><span class="p">(</span><span class="n">tangentWS</span><span class="p">,</span> <span class="n">bitangentWS</span><span class="p">,</span> <span class="n">normalWS</span><span class="p">);</span>
 <span class="n">half3</span> <span class="n">lightWS</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
 <span class="n">float3</span> <span class="n">viewDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">positionWS</span><span class="p">);</span>
 <span class="c1">//tex</span>
 <span class="n">float3</span> <span class="n">lightColor</span> <span class="o">=</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
 <span class="n">float4</span> <span class="n">baseCol</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span>
 <span class="n">float3</span> <span class="n">normalMapData</span> <span class="o">=</span> <span class="n">UnpackNormal</span><span class="p">(</span><span class="n">tex2D</span><span class="p">(</span><span class="n">_NormalMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
 <span class="n">normalMapData</span><span class="p">.</span><span class="n">xy</span> <span class="o">*=</span> <span class="n">_NormalMapScale</span><span class="p">;</span>
 <span class="c1">//halfLambet</span>
 <span class="n">float3</span> <span class="n">pixelNormal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">normalMapData</span><span class="p">,</span> <span class="n">TBN</span><span class="p">));</span>
 <span class="kt">float</span> <span class="n">noL</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">pixelNormal</span><span class="p">,</span> <span class="n">lightWS</span><span class="p">));</span>
 <span class="kt">float</span> <span class="n">halfLambet</span> <span class="o">=</span> <span class="n">noL</span><span class="o">*</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>
 
    <span class="c1">//Specular</span>
    <span class="c1">//phong</span>
    <span class="n">half3</span> <span class="n">reflectDir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">lightWS</span><span class="p">,</span> <span class="n">pixelNormal</span><span class="p">);</span>
    <span class="n">half</span> <span class="n">phongItem</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">reflectDir</span><span class="p">,</span> <span class="n">viewDir</span><span class="p">));</span>
    <span class="n">half3</span> <span class="n">phongSpecular</span> <span class="o">=</span> <span class="n">_SpecularColor</span><span class="p">.</span><span class="n">xyz</span> <span class="o">*</span> <span class="n">_SpecularIntensity</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">phongItem</span><span class="p">,</span> <span class="n">_SpecularShininess</span><span class="p">)</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>
    <span class="c1">//Blinn-phong</span>
    <span class="n">half3</span> <span class="n">halfDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightWS</span> <span class="o">+</span> <span class="n">viewDir</span><span class="p">);</span>
    <span class="n">half</span> <span class="n">blinnPhongItem</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">pixelNormal</span><span class="p">,</span> <span class="n">halfDir</span><span class="p">));</span>
    <span class="n">half3</span> <span class="n">blinnPhongSpecular</span> <span class="o">=</span> <span class="n">_SpecularColor</span><span class="p">.</span><span class="n">xyz</span> <span class="o">*</span> <span class="n">_SpecularIntensity</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">blinnPhongItem</span><span class="p">,</span> <span class="n">_SpecularShininess</span><span class="p">)</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>
    
    <span class="c1">//Shadow</span>
    <span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">SHADOW_ATTENUATION</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="c1">//output</span>
    <span class="n">float3</span> <span class="n">finalColor</span> <span class="o">=</span> <span class="n">baseCol</span> <span class="o">*</span><span class="n">halfLambet</span> <span class="o">*</span> <span class="n">lightColor</span> <span class="o">*</span><span class="n">shadow</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">float4</span><span class="p">(</span><span class="n">finalColor</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>]]></content><author><name></name></author><category term="TAMonth01"/><category term="学习笔记"/><category term="学习"/><category term="math"/><summary type="html"><![CDATA[镜面反射光照模型Phong和Blinn-Phong]]></summary></entry><entry><title type="html">Lv.2 Unity主线：添加多光源交互</title><link href="https://xueqingzhe.github.io/blog/2025/Lv.2-Unity%E4%B8%BB%E7%BA%BF-%E6%B7%BB%E5%8A%A0%E5%A4%9A%E5%85%89%E6%BA%90%E4%BA%A4%E4%BA%92/" rel="alternate" type="text/html" title="Lv.2 Unity主线：添加多光源交互"/><published>2025-12-21T00:00:00+00:00</published><updated>2025-12-21T00:00:00+00:00</updated><id>https://xueqingzhe.github.io/blog/2025/Lv.2%20Unity%E4%B8%BB%E7%BA%BF%EF%BC%9A%E6%B7%BB%E5%8A%A0%E5%A4%9A%E5%85%89%E6%BA%90%E4%BA%A4%E4%BA%92</id><content type="html" xml:base="https://xueqingzhe.github.io/blog/2025/Lv.2-Unity%E4%B8%BB%E7%BA%BF-%E6%B7%BB%E5%8A%A0%E5%A4%9A%E5%85%89%E6%BA%90%E4%BA%A4%E4%BA%92/"><![CDATA[<h1 id="前向渲染多光源必要代码">前向渲染多光源必要代码</h1> <h1 id="shader-pass">Shader Pass</h1> <p><strong>一般是单Pass，也就是ForwardPass，进行处理主光源（平行光），多光源设置实际上就是添加一个新的Pass处理点光和射光，注意不包括面光。这个Pass就是ForwardAddPass</strong></p> <h2 id="结构体的声明要求">结构体的声明要求</h2> <p><strong><em>顶点的命名必须固定为vertex和pos</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251210193256.png" alt="图片"/> <strong><em>原函数在生成平行光的阴影时不会访问物体空间顶点位置，因为平行光不会衰减而且单一方向，所以它直接使用裁剪空间下的位置计算出阴影图，但是对于点光，因为点光是一个球型范围衰减，它需要生成一个cubemap阴影图，所以需要使用顶点位置信息，因为通常情况是顶点数比片元更少，所以使用物体空间的顶点位置vertex进行矩阵变换到点光源空间计算得到cubemap阴影图。</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251210193016.png" alt="图片"/></p> <h2 id="forwardpass">ForwardPass</h2> <h3 id="tags">Tags</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="n">Name</span> <span class="s">"Forward"</span>
<span class="n">Tags</span>
<span class="p">{</span>
    <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ForwardBase"</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h3 id="pragma指令">pragma指令</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="cp">#pragma multi_compile_fwdbase
</span></pre></td></tr></tbody></table></code></pre></div></div> <h3 id="include">include</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp">
#include</span> <span class="cpf">"Lighting.cginc"</span><span class="cp">
#include</span> <span class="cpf">"AutoLight.cginc"</span><span class="c1">            </span><span class="cp">
</span></pre></td></tr></tbody></table></code></pre></div></div> <h3 id="阴影和光照衰减函数">阴影和光照衰减函数</h3> <p><strong><em>对于ForwardBasePass处理阴影的时候是使用SHADOW_ATTENUATION(i)，多光源投射的阴影是另外的函数</em></strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="c1">// 计算阴影衰减（自动处理所有阴影类型）</span>
<span class="n">fixed</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">SHADOW_ATTENUATION</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="forwardaddpass">ForwardAddPass</h2> <p><strong>处理ForwardAddPass，可以直接将原Pass进行拷贝就行，大部分是一样的</strong>*</p> <h3 id="tags-1">Tags</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="n">Name</span><span class="s">"ForwadAdd"</span>
<span class="n">Tags</span>
<span class="p">{</span>
    <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ForwardAdd"</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h3 id="pragma指令-1">pragma指令</h3> <p><strong>这里多光源的指令有两条，按需使用</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="c1">// 无阴影仅光源衰减需要的变体</span>
<span class="cp">#pragma multi_compile_fwdadd
</span><span class="c1">// 使用带阴影的编译指令</span>
<span class="cp">#pragma multi_compile_fwdadd_fullshadows
</span></pre></td></tr></tbody></table></code></pre></div></div> <p><strong><em>带阴影指令实际上是给这里使用的，也就是点光的照射阴影，如果不使用fullshadows那么怎么调都是没有的</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251210192136.png" alt="图片"/> <strong><em>相当于额外的光照阴影</em></strong></p> <h3 id="关键字">关键字</h3> <p><strong><em>光照叠加使用加法混合</em></strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">Blend</span> <span class="n">One</span> <span class="n">One</span>  <span class="c1">// 加法混合是关键</span>
<span class="n">ZWrite</span> <span class="n">Off</span>     <span class="c1">// 避免深度冲突</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h3 id="光源判断">光源判断</h3> <p><strong><em>使用宏判断</em></strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre> <span class="c1">// 关键：附加光源的方向计算</span>
<span class="cp">#ifdef USING_DIRECTIONAL_LIGHT
</span>    <span class="n">float3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
<span class="cp">#else
</span>    <span class="n">float3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">posWS</span><span class="p">);</span>
<span class="cp">#endif
</span></pre></td></tr></tbody></table></code></pre></div></div> <p><strong><em>_WorldSpaceLightPos0.w灯光标记判断，0是平行光，1是非平行光</em></strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="c1">//平行光源向量</span>
<span class="n">half3</span> <span class="n">light_dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
<span class="c1">//点光源向量</span>
<span class="n">half3</span> <span class="n">light_dir_point</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">pos_world</span><span class="p">);</span>   
<span class="c1">//_WorldSpaceLightPos0.w可以判断光源类型</span>
<span class="n">light_dir</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">light_dir</span><span class="p">,</span> <span class="n">light_dir_point</span><span class="p">,</span> <span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">w</span><span class="p">);</span> 
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong><em>如果想要手动控制衰减，可以判断分类即可，一般不推荐</em></strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="cp">#if defined (DIRECTIONAL)
</span><span class="n">half3</span> <span class="n">light_dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>   <span class="c1">//主光源向量</span>
<span class="n">half</span> <span class="n">attuenation</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="cp">#elif defined (POINT)
</span><span class="n">half3</span> <span class="n">light_dir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">pos_world</span><span class="p">);</span>   <span class="c1">//主光源向量</span>
<span class="n">half</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">pos_world</span><span class="p">);</span>
<span class="n">half</span> <span class="n">range</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="n">unity_WorldToLight</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span><span class="c1">//获取点光源的range属性</span>
<span class="n">half</span> <span class="n">attuenation</span> <span class="o">=</span> <span class="n">saturate</span><span class="p">((</span><span class="n">range</span> <span class="o">-</span> <span class="n">distance</span><span class="p">)</span><span class="o">/</span><span class="n">range</span><span class="p">);</span><span class="c1">//光照衰减系数，平行光无衰减</span>
<span class="cp">#endif
</span></pre></td></tr></tbody></table></code></pre></div></div> <h3 id="阴影和光照衰减函数-1">阴影和光照衰减函数</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="c1">// 阴影和衰减 atten是创建接收的变量，i是指输入的v2f结构</span>
<span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">atten</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">posWS</span><span class="p">);</span>
<span class="c1">//atten不需要声明，直接乘法混合就行</span>
<span class="n">fixed3</span> <span class="n">finalCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">nol</span> <span class="o">*</span> <span class="n">atten</span> <span class="o">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h1 id="前向渲染和延迟渲染的光源数量和渲染处理">前向渲染和延迟渲染的光源数量和渲染处理</h1> <h2 id="前向渲染灯光处理">前向渲染灯光处理</h2> <p><strong>这里我在场景中加了很多光源，材质就是默认的standard材质</strong> <img src="/assets/img/TAMonth01/Pasted image 20251212191952.png" alt="图片"/></p> <h3 id="framedebuger">FrameDebuger</h3> <p><strong>使用FrameDebuger可以看到每个光源对于每个物体Mesh都需要单独计算渲染一次，那么理所当然光源越多，消耗越大，灯光数量需要进行严格的控制，对于大场景自然不能使用前向渲染</strong> <img src="/assets/img/TAMonth01/前向渲染多光源 1.gif" alt="图片"/> <strong>同时当灯光超过规定数量时，会自动降级为顶点灯光，也就是不在片元计算，像素一般来说是比顶点多的多的，所以顶点光照质量就会非常差</strong> <img src="/assets/img/TAMonth01/Pasted image 20251212192957.png" alt="图片"/></p> <h2 id="延迟渲染灯光处理">延迟渲染灯光处理</h2> <h3 id="开启延迟渲染">开启延迟渲染</h3> <p><strong>找到MainCamera里面的渲染设置更改为Deferred</strong> <img src="/assets/img/TAMonth01/Pasted image 20251212193424.png" alt="图片"/></p> <h3 id="framedebuger-1">FrameDebuger</h3> <p><strong>延迟渲染下，因为是先统一输出Guffer，然后再统一计算，所以可以看出绘制数明显降低，相当于把物体合批在绘制灯光了</strong> <img src="/assets/img/TAMonth01/延迟渲染多光源.gif" alt="图片"/></p> <h1 id="延迟渲染必要代码">延迟渲染必要代码</h1> <p><strong>延迟渲染是灯光都在一个Pass中处理</strong></p> <h2 id="tags-2">Tags</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">Tags</span> <span class="p">{</span> <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"Deferred"</span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="pragma">pragma</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="cp">#pragma exclude_renderers nomrt
</span>
<span class="c1">// 意思是：</span>
<span class="c1">// "排除那些不支持MRT的渲染器（平台）"</span>
<span class="c1">// 也就是：只在支持MRT的平台上编译和运行这个Shader</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="额外的输出结构体">额外的输出结构体</h2> <p><strong>将需要输出的内容分别输出，最多8个，一般输出4个</strong>*</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">GBuffer</span>
            <span class="p">{</span>
                <span class="n">half4</span> <span class="n">diffuse</span> <span class="o">:</span> <span class="n">SV_Target0</span><span class="p">;</span>
                <span class="n">half4</span> <span class="n">spec</span> <span class="o">:</span> <span class="n">SV_Target1</span><span class="p">;</span>
                <span class="n">half4</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">SV_Target2</span><span class="p">;</span>
                <span class="n">half4</span> <span class="n">emission</span> <span class="o">:</span> <span class="n">SV_Target3</span><span class="p">;</span>
            <span class="p">};</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="片元着色器">片元着色器</h2> <p><strong>不需要计算光照，直接将对应数据输出就行，同时frag函数后面不需要加SV_Target</strong> <img src="/assets/img/TAMonth01/Pasted image 20251212200035.png" alt="图片"/></p> <h1 id="代码参考">代码参考</h1> <p><strong>为了方便两种切换，所以就直接加上延迟渲染Pass了</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
</pre></td><td class="rouge-code"><pre><span class="n">Shader</span> <span class="s">"Unlit/AddLight_Deferred"</span>

<span class="p">{</span>

    <span class="n">Properties</span>
    <span class="p">{</span>
        <span class="n">_MainTex</span> <span class="p">(</span><span class="s">"Texture"</span><span class="p">,</span> <span class="mi">2</span><span class="n">D</span><span class="p">)</span> <span class="o">=</span> <span class="s">"white"</span> <span class="p">{}</span>

    <span class="p">}</span>
    <span class="n">SubShader</span>
    <span class="p">{</span>
        <span class="n">Tags</span> <span class="p">{</span> <span class="s">"RenderType"</span><span class="o">=</span><span class="s">"Opaque"</span> <span class="p">}</span>
        <span class="n">LOD</span> <span class="mi">100</span>
        <span class="n">CGINCLUDE</span>
        <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp">
</span>        <span class="n">sampler2D</span> <span class="n">_MainTex</span><span class="p">;</span>
        <span class="n">float4</span> <span class="n">_MainTex_ST</span><span class="p">;</span>
        <span class="n">ENDCG</span>
        <span class="n">Pass</span>
        <span class="p">{</span>
            <span class="n">Name</span> <span class="s">"Deferred"</span>
            <span class="n">Tags</span> <span class="p">{</span> <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"Deferred"</span> <span class="p">}</span>
            <span class="n">CGPROGRAM</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>            <span class="cp">#pragma exclude_renderers nomrt
</span>            <span class="cp">#pragma target 3.0
</span>            <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp">
</span>
            <span class="k">struct</span> <span class="n">appdata</span>

            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
                <span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="n">v2f</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
                <span class="n">float2</span> <span class="n">uv</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">normalWS</span> <span class="o">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="n">GBuffer</span>
            <span class="p">{</span>
                <span class="n">half4</span> <span class="n">diffuse</span> <span class="o">:</span> <span class="n">SV_Target0</span><span class="p">;</span>
                <span class="n">half4</span> <span class="n">spec</span> <span class="o">:</span> <span class="n">SV_Target1</span><span class="p">;</span>
                <span class="n">half4</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">SV_Target2</span><span class="p">;</span>
                <span class="n">half4</span> <span class="n">emission</span> <span class="o">:</span> <span class="n">SV_Target3</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">uv</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">normalWS</span> <span class="o">=</span> <span class="n">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">GBuffer</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">fixed4</span> <span class="n">albedo</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">uv</span><span class="p">);</span>
                <span class="n">float3</span> <span class="n">normalWS</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normalWS</span><span class="p">);</span>

                <span class="n">GBuffer</span> <span class="n">output</span><span class="p">;</span>
                <span class="n">output</span><span class="p">.</span><span class="n">diffuse</span> <span class="o">=</span> <span class="n">half4</span><span class="p">(</span><span class="n">albedo</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
                <span class="n">output</span><span class="p">.</span><span class="n">spec</span> <span class="o">=</span> <span class="n">half4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mo">04</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mo">04</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mo">04</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">);</span>
                <span class="n">output</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">half4</span><span class="p">(</span><span class="n">normalWS</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
                <span class="n">output</span><span class="p">.</span><span class="n">emission</span> <span class="o">=</span> <span class="n">half4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">output</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">ENDCG</span>

        <span class="p">}</span>

        <span class="n">Pass</span>
        <span class="p">{</span>
           <span class="n">Name</span> <span class="s">"Forward"</span>
           <span class="n">Tags</span><span class="p">{</span>
            <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ForwardBase"</span>
           <span class="p">}</span>

            <span class="n">CGPROGRAM</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>            <span class="c1">// make fog work</span>
            <span class="cp">#pragma multi_compile_fwdbase
</span>
            <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp">
</span>            <span class="cp">#include</span> <span class="cpf">"Lighting.cginc"</span><span class="cp">
</span>            <span class="cp">#include</span> <span class="cpf">"AutoLight.cginc"</span><span class="c1">             // 阴影宏定义在这里</span><span class="cp">
</span>
            <span class="k">struct</span> <span class="n">appdata</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span>   <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
                <span class="n">float2</span> <span class="n">uv</span>       <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">normal</span>   <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>
                <span class="n">float4</span> <span class="n">tangent</span>  <span class="o">:</span> <span class="n">TANGENT</span><span class="p">;</span>
            <span class="p">};</span>

  
            <span class="k">struct</span> <span class="n">v2f</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">pos</span> <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
                <span class="n">float2</span> <span class="n">texcoord</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">posWS</span> <span class="o">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">normalWS</span> <span class="o">:</span><span class="n">TEXCOORD2</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">tangentWS</span><span class="o">:</span> <span class="n">TEXCOORD3</span><span class="p">;</span>
                <span class="c1">// 阴影坐标声明（自动处理多个变体）</span>
                <span class="n">UNITY_SHADOW_COORDS</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="p">};</span>

            <span class="c1">//sampler2D _MainTex;</span>
            <span class="c1">//float4 _MainTex_ST;</span>

            <span class="n">v2f</span> <span class="n">vert</span> <span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">texcoord</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">posWS</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">normalWS</span> <span class="o">=</span> <span class="n">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">tangentWS</span> <span class="o">=</span> <span class="n">UnityObjectToWorldDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">);</span>

                <span class="c1">// 传输阴影数据（关键！）</span>
                <span class="n">TRANSFER_SHADOW</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>

                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>

            <span class="p">}</span>

  

            <span class="n">fixed4</span> <span class="n">frag</span> <span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
            <span class="p">{</span>
                <span class="c1">// sample the texture</span>
                <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span>

                <span class="n">float3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
                <span class="kt">float</span> <span class="n">nol</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normalWS</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

                <span class="c1">// 计算阴影衰减（自动处理所有阴影类型）</span>
                <span class="n">fixed</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">SHADOW_ATTENUATION</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

                <span class="n">fixed3</span> <span class="n">finalCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">nol</span> <span class="o">*</span> <span class="n">shadow</span> <span class="o">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">finalCol</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">ENDCG</span>

        <span class="p">}</span>

        <span class="n">Pass</span>
        <span class="p">{</span>
            <span class="n">Name</span><span class="s">"ForwadAdd"</span>
            <span class="n">Tags</span>
            <span class="p">{</span>
                <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ForwardAdd"</span>
            <span class="p">}</span>

            <span class="n">Blend</span> <span class="n">One</span> <span class="n">One</span>  <span class="c1">// 加法混合是关键！</span>
            <span class="n">ZWrite</span> <span class="n">Off</span>     <span class="c1">// 避免深度冲突</span>

            <span class="n">CGPROGRAM</span>

            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>            <span class="c1">// 无阴影仅光源衰减需要的变体</span>
            <span class="c1">//#pragma multi_compile_fwdadd</span>
            <span class="c1">// 使用带阴影的编译指令</span>
            <span class="cp">#pragma multi_compile_fwdadd_fullshadows
</span>
            <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp">
</span>            <span class="cp">#include</span> <span class="cpf">"Lighting.cginc"</span><span class="cp">
</span>            <span class="cp">#include</span> <span class="cpf">"AutoLight.cginc"</span><span class="cp">
</span>
  

            <span class="k">struct</span> <span class="n">appdata</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span>  <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
                <span class="n">float2</span> <span class="n">uv</span>      <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">normal</span>  <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>
                <span class="n">float4</span> <span class="n">tangent</span> <span class="o">:</span> <span class="n">TANGENT</span><span class="p">;</span>
            <span class="p">};</span>

  

            <span class="k">struct</span> <span class="n">v2f</span>
            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">pos</span>      <span class="o">:</span> <span class="n">SV_POSITION</span><span class="p">;</span>
                <span class="n">float2</span> <span class="n">texcoord</span> <span class="o">:</span> <span class="n">TEXCOORD0</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">posWS</span>    <span class="o">:</span> <span class="n">TEXCOORD1</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">normalWS</span> <span class="o">:</span> <span class="n">TEXCOORD2</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">tangentWS</span><span class="o">:</span> <span class="n">TEXCOORD3</span><span class="p">;</span>

                <span class="c1">// 阴影坐标声明（自动处理多个变体）</span>
                <span class="n">UNITY_SHADOW_COORDS</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
            <span class="p">};</span>

  

            <span class="c1">// sampler2D _MainTex;</span>
            <span class="c1">// float4 _MainTex_ST;</span>
            <span class="n">v2f</span> <span class="n">vert</span> <span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="n">o</span><span class="p">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">UnityObjectToClipPos</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">texcoord</span> <span class="o">=</span> <span class="n">TRANSFORM_TEX</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">uv</span><span class="p">,</span> <span class="n">_MainTex</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">posWS</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">unity_ObjectToWorld</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">vertex</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">normalWS</span> <span class="o">=</span> <span class="n">UnityObjectToWorldNormal</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">normal</span><span class="p">);</span>
                <span class="n">o</span><span class="p">.</span><span class="n">tangentWS</span> <span class="o">=</span> <span class="n">UnityObjectToWorldDir</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">tangent</span><span class="p">);</span>

                <span class="c1">// 传输阴影数据（关键！）</span>
                <span class="n">TRANSFER_SHADOW</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

  

            <span class="n">fixed4</span> <span class="n">frag</span> <span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
            <span class="p">{</span>

                <span class="c1">// sample the texture</span>
                <span class="n">fixed4</span> <span class="n">col</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span>

                <span class="c1">// 关键：附加光源的方向计算</span>
                <span class="cp">#ifdef USING_DIRECTIONAL_LIGHT
</span>                    <span class="n">float3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
                <span class="cp">#else
</span>                    <span class="n">float3</span> <span class="n">lightDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">posWS</span><span class="p">);</span>
                <span class="cp">#endif
</span>
                <span class="c1">// 计算阴影衰减（自动处理所有阴影类型）</span>
                <span class="c1">//fixed shadow = SHADOW_ATTENUATION(i);</span>

                <span class="kt">float</span> <span class="n">nol</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normalWS</span><span class="p">,</span> <span class="n">lightDir</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

                <span class="c1">// 阴影和衰减</span>
                <span class="n">UNITY_LIGHT_ATTENUATION</span><span class="p">(</span><span class="n">atten</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">posWS</span><span class="p">);</span>

  

                <span class="n">fixed3</span> <span class="n">finalCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">nol</span> <span class="o">*</span> <span class="n">atten</span> <span class="o">*</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">fixed4</span><span class="p">(</span><span class="n">finalCol</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

            <span class="p">}</span>
            <span class="n">ENDCG</span>
        <span class="p">}</span>

        <span class="n">Pass</span>
        <span class="p">{</span>

            <span class="n">Name</span><span class="s">"ShadowCaster"</span>
            <span class="n">Tags</span><span class="p">{</span>
                <span class="s">"LightMode"</span> <span class="o">=</span> <span class="s">"ShadowCaster"</span>
            <span class="p">}</span>

            <span class="n">CGPROGRAM</span>
            <span class="cp">#pragma vertex vert
</span>            <span class="cp">#pragma fragment frag
</span>
            <span class="c1">// 阴影投射需要的变体</span>
            <span class="cp">#pragma multi_compile_shadowcaster
</span>            <span class="cp">#include</span> <span class="cpf">"UnityCG.cginc"</span><span class="cp">
</span>
            <span class="k">struct</span> <span class="n">appdata</span>

            <span class="p">{</span>
                <span class="n">float4</span> <span class="n">vertex</span> <span class="o">:</span> <span class="n">POSITION</span><span class="p">;</span>
                <span class="n">float3</span> <span class="n">normal</span> <span class="o">:</span> <span class="n">NORMAL</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="k">struct</span> <span class="n">v2f</span>
            <span class="p">{</span>
                <span class="n">V2F_SHADOW_CASTER</span><span class="p">;</span>  <span class="c1">// Unity预定义的结构</span>
            <span class="p">};</span>

            <span class="n">v2f</span> <span class="n">vert</span><span class="p">(</span><span class="n">appdata</span> <span class="n">v</span><span class="p">)</span>
            <span class="p">{</span>

                <span class="n">v2f</span> <span class="n">o</span><span class="p">;</span>
                <span class="n">TRANSFER_SHADOW_CASTER_NORMALOFFSET</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>  <span class="c1">// 转换到阴影空间</span>
                <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">fixed4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
            <span class="p">{</span>
                <span class="n">SHADOW_CASTER_FRAGMENT</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>  <span class="c1">// 写入阴影深度</span>
            <span class="p">}</span>
            <span class="n">ENDCG</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">FallBack</span> <span class="s">"Diffuse"</span>
<span class="p">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>]]></content><author><name></name></author><category term="TAMonth01"/><category term="shader"/><category term="rendering"/><category term="unity"/><summary type="html"><![CDATA[如何多光源交互]]></summary></entry><entry><title type="html">Lv.2 Unity主线：添加环境光</title><link href="https://xueqingzhe.github.io/blog/2025/Lv.2-Unity%E4%B8%BB%E7%BA%BF-%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%85%89/" rel="alternate" type="text/html" title="Lv.2 Unity主线：添加环境光"/><published>2025-12-21T00:00:00+00:00</published><updated>2025-12-21T00:00:00+00:00</updated><id>https://xueqingzhe.github.io/blog/2025/Lv.2%20Unity%E4%B8%BB%E7%BA%BF%EF%BC%9A%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%85%89</id><content type="html" xml:base="https://xueqingzhe.github.io/blog/2025/Lv.2-Unity%E4%B8%BB%E7%BA%BF-%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%85%89/"><![CDATA[<h1 id="环境光照">环境光照</h1> <p>在实时渲染中，环境光照有几种方式：</p> <table> <thead> <tr> <th>方法</th> <th>原理</th> <th>优点</th> <th>缺点</th> </tr> </thead> <tbody> <tr> <td><strong>常量环境光</strong></td> <td><code class="language-plaintext highlighter-rouge">ambient = color</code></td> <td>简单</td> <td>不真实，没有方向性</td> </tr> <tr> <td><strong>环境贴图采样</strong></td> <td>直接从 Cubemap 采样</td> <td>精确</td> <td>太慢（实时性差）</td> </tr> <tr> <td><strong>球谐光照</strong></td> <td>用数学函数近似环境光</td> <td>快速 + 较准确</td> <td>需要预计算</td> </tr> </tbody> </table> <h2 id="环境光漫反射">环境光漫反射</h2> <p><strong>两种计算方式选其一</strong></p> <h3 id="unity内置颜色">Unity内置颜色</h3> <p><strong>仅天光，不支持天空盒Skybox颜色，漫反射环境光</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>   <span class="c1">// 环境光（Unity 自动处理）</span>
    <span class="n">fixed3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">UNITY_LIGHTMODEL_AMBIENT</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">albedo</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
    <span class="c1">//               ^^^^^^^^^^^^^^^^^^^^^^^ Unity 内置的环境光颜色</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h3 id="球谐函数">球谐函数</h3> <p><strong>支持 Skybox/Gradient/Color，漫反射环境光</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="c1">// 环境光（支持 Skybox/Gradient/Color）</span>
    <span class="n">fixed3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="n">half4</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normalWS</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">albedo</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
    <span class="c1">//               ^^^^^^^ Unity 的球谐函数，根据法线方向采样环境光</span>
    
    <span class="n">ambient</span> <span class="o">*=</span> <span class="n">albedo</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>  <span class="c1">// 乘以基础颜色</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="环境光镜面反射">环境光镜面反射</h2> <p><strong>环境光镜面反射其实就是采样环境贴图，比如说HDR、EXR等等格式的图片，两种计算方式选其一</strong></p> <h3 id="采样反射探针">采样反射探针</h3> <p>DirectX 11 / OpenGL ES 3.0+ Fragment Shader最多支持 16个纹理采样器 但Cubemap算6个面，实际占用看平台实现 Unity同时最多混合 2个反射探针 <strong>场景中拖入反射探针进行烘焙然后再采样的</strong> <img src="/assets/img/TAMonth01/Pasted image 20251215214920.png" alt="图片"/> <strong>如果想把某个物体烘焙到CubeMap中，需要进行设置标签</strong> <img src="/assets/img/TAMonth01/Pasted image 20251215215013.png" alt="图片"/> <strong>场景默认会有一个全局反射探针，在Lighting设置中进行生成即可，就不用手动添加了，但是全局烘焙的不会含有物体，因为需要轻量化和统一，只包含天空盒SkyBox，需要烘焙物体的话还是得手动加反射探针</strong> <img src="/assets/img/TAMonth01/Pasted image 20251215215215.png" alt="图片"/></p> <p><strong>用于金属类的，镜面反射环境光</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="c1">// 采样反射探针（Reflection Probe）</span>
<span class="n">half4</span> <span class="n">skyData</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEXCUBE</span><span class="p">(</span><span class="n">unity_SpecCube0</span><span class="p">,</span> <span class="n">reflectDir</span><span class="p">);</span>
<span class="n">half3</span> <span class="n">skyColor</span> <span class="o">=</span> <span class="n">DecodeHDR</span><span class="p">(</span><span class="n">skyData</span><span class="p">,</span> <span class="n">unity_SpecCube0_HDR</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h3 id="采样cubemap图">采样CubeMap图</h3> <p><strong>和反射探针类似</strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="n">_Cubemap</span> <span class="p">(</span><span class="s">"Environment Cubemap"</span><span class="p">,</span> <span class="n">Cube</span><span class="p">)</span> <span class="o">=</span> <span class="s">"white"</span> <span class="p">{}</span>
<span class="o">------------------------------</span>
<span class="n">samplerCUBE</span> <span class="n">_CubeMap</span><span class="p">;</span>
<span class="n">float4</span> <span class="n">_CubeMap_HDR</span><span class="p">;</span> <span class="c1">//此参数声明后，Unity会自动配置</span>
<span class="o">------------------------------</span>
<span class="c1">// 计算反射方向</span>
<span class="n">float3</span> <span class="n">viewDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">i</span><span class="p">.</span><span class="n">worldPos</span><span class="p">);</span>
<span class="n">float3</span> <span class="n">reflDir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">viewDir</span><span class="p">,</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">worldNormal</span><span class="p">));</span>
<span class="c1">// 采样Cubemap</span>
<span class="n">half4</span> <span class="n">reflColor</span> <span class="o">=</span> <span class="n">texCUBE</span><span class="p">(</span><span class="n">_Cubemap</span><span class="p">,</span> <span class="n">reflDir</span><span class="p">);</span>
<span class="c1">//如果采样发现模糊，那么就需要指定lod0</span>
<span class="n">half4</span> <span class="n">reflColor</span> <span class="o">=</span> <span class="n">texCUBElod</span><span class="p">(</span><span class="n">_CubeMap</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="n">reflectDir</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
<span class="c1">//同时也需要进行DecodeHDR</span>
<span class="n">half3</span> <span class="n">reflRGB</span> <span class="o">=</span> <span class="n">DecodeHDR</span><span class="p">(</span><span class="n">reflColor</span><span class="p">,</span> <span class="n">_CubeMap_HDR</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div> <p><strong>只要 Cubemap 是 HDR 格式（EXR / HDR / RGBM），采样后就一定要 <code class="language-plaintext highlighter-rouge">DecodeHDR</code><br/> 只有 LDR（PNG / JPG）才可以直接用!!!</strong> <strong><em>如果发现环境光镜面反射叠加效果阴影中也有的话，这其实是正确的。阴影区本来就有镜面反射，但是它的强度应该由AO（环境光遮蔽）控制，也就是AO贴图。</em></strong> <img src="/assets/img/TAMonth01/Pasted image 20251223214542.png" alt="图片"/> <strong><em>如果没有AO，可以随意整个假的AO，例如下面这样</em></strong></p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="c1">//AO控制</span>
<span class="kt">float</span> <span class="n">fakeAO</span> <span class="o">=</span> <span class="n">saturate</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normalWS</span><span class="p">,</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)));</span>
<span class="n">reflRGB</span> <span class="o">*=</span> <span class="n">fakeAO</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div> <h2 id="环境光组成">环境光组成</h2> <p><strong>非金属和金属的都必须包含高光，但是环境光镜面反射是只有光滑物体或者金属才有，然后镜面反射会和粗糙度关联控制，这个后面会补充</strong></p> <p><strong>环境光 = 环境光SH漫反射 + 环境光镜面反射</strong></p> <h2 id="参考性能">参考性能</h2> <table> <thead> <tr> <th>方法</th> <th>性能</th> <th>效果</th> <th>适用场景</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">UNITY_LIGHTMODEL_AMBIENT</code></td> <td>最快</td> <td>最简单</td> <td>移动端/性能优先</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">ShadeSH9</code></td> <td>快</td> <td>好</td> <td><strong>推荐，通用</strong></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">ShadeSH9</code> + 反射探针</td> <td>中等</td> <td>很好</td> <td>PC/主机高质量</td> </tr> <tr> <td>实时 GI</td> <td>慢</td> <td>最好</td> <td>高端项目</td> </tr> </tbody> </table> <h1 id="最终片元代码参考">最终片元代码参考</h1> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre></td><td class="rouge-code"><pre><span class="n">float4</span> <span class="n">frag</span><span class="p">(</span><span class="n">v2f</span> <span class="n">i</span><span class="p">)</span> <span class="o">:</span> <span class="n">SV_Target</span>
<span class="p">{</span>
    <span class="c1">//vectors</span>
    <span class="n">float3</span> <span class="n">positionWS</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">positionWS</span><span class="p">;</span> 
    <span class="n">float3</span> <span class="n">normalWS</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">normalWS</span><span class="p">);</span>
    <span class="n">float3</span> <span class="n">tangentWS</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">tangentWS</span><span class="p">);</span>
    <span class="n">float3</span> <span class="n">bitangentWS</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">bitangentWS</span><span class="p">);</span>
    <span class="n">float3x3</span> <span class="n">TBN</span> <span class="o">=</span> <span class="n">float3x3</span><span class="p">(</span><span class="n">tangentWS</span><span class="p">,</span> <span class="n">bitangentWS</span><span class="p">,</span> <span class="n">normalWS</span><span class="p">);</span>
    <span class="n">half3</span> <span class="n">lightWS</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceLightPos0</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
    <span class="n">float3</span> <span class="n">viewDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">_WorldSpaceCameraPos</span> <span class="o">-</span> <span class="n">positionWS</span><span class="p">);</span>
    <span class="c1">//tex</span>
    <span class="n">float3</span> <span class="n">lightColor</span> <span class="o">=</span> <span class="n">_LightColor0</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">float4</span> <span class="n">baseCol</span> <span class="o">=</span> <span class="n">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span>
    <span class="n">float3</span> <span class="n">normalMapData</span> <span class="o">=</span> <span class="n">UnpackNormal</span><span class="p">(</span><span class="n">tex2D</span><span class="p">(</span><span class="n">_NormalMap</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">texcoord</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="n">normalMapData</span><span class="p">.</span><span class="n">xy</span> <span class="o">*=</span> <span class="n">_NormalMapScale</span><span class="p">;</span>
    <span class="c1">//halfLambet</span>
    <span class="n">float3</span> <span class="n">pixelNormal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">normalMapData</span><span class="p">,</span> <span class="n">TBN</span><span class="p">));</span>
    <span class="kt">float</span> <span class="n">noL</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">pixelNormal</span><span class="p">,</span> <span class="n">lightWS</span><span class="p">));</span>
    <span class="kt">float</span> <span class="n">halfLambet</span> <span class="o">=</span> <span class="n">noL</span><span class="o">*</span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">;</span>

 <span class="c1">//Specular</span>
 <span class="c1">//phong</span>
 <span class="n">half3</span> <span class="n">reflectDir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">lightWS</span><span class="p">,</span> <span class="n">pixelNormal</span><span class="p">);</span>
 <span class="n">half</span> <span class="n">phongItem</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">reflectDir</span><span class="p">,</span> <span class="n">viewDir</span><span class="p">));</span>
 <span class="n">half3</span> <span class="n">phongSpecular</span> <span class="o">=</span> <span class="n">_SpecularColor</span><span class="p">.</span><span class="n">xyz</span> <span class="o">*</span> <span class="n">_SpecularIntensity</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">phongItem</span><span class="p">,</span> <span class="n">_SpecularShininess</span><span class="p">)</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>
 <span class="c1">//Blinn-phong</span>
 <span class="n">half3</span> <span class="n">halfDir</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightWS</span> <span class="o">+</span> <span class="n">viewDir</span><span class="p">);</span>
 <span class="n">half</span> <span class="n">blinnPhongItem</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">pixelNormal</span><span class="p">,</span> <span class="n">halfDir</span><span class="p">));</span>
 <span class="n">half3</span> <span class="n">blinnPhongSpecular</span> <span class="o">=</span> <span class="n">_SpecularColor</span><span class="p">.</span><span class="n">xyz</span> <span class="o">*</span> <span class="n">_SpecularIntensity</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">blinnPhongItem</span><span class="p">,</span> <span class="n">_SpecularShininess</span><span class="p">)</span> <span class="o">*</span> <span class="n">lightColor</span><span class="p">;</span>

 <span class="cm">/******************漫反射环境光*********************/</span>
 <span class="c1">//EnvironmentColor</span>
 <span class="c1">//1.环境光（Unity 自动处理）</span>
 <span class="n">fixed3</span> <span class="n">envColor</span> <span class="o">=</span> <span class="n">UNITY_LIGHTMODEL_AMBIENT</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">baseCol</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
 <span class="c1">//               ^^^^^^^^^^^^^^^^^^^^^^^ Unity 内置的环境光颜色</span>
 <span class="c1">//2.SH环境光（支持 Skybox/Gradient/Color）</span>
 <span class="n">fixed3</span> <span class="n">envColorSH</span> <span class="o">=</span> <span class="n">ShadeSH9</span><span class="p">(</span><span class="n">half4</span><span class="p">(</span><span class="n">normalWS</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="n">baseCol</span><span class="p">.</span><span class="n">rgb</span><span class="p">;</span>
 <span class="c1">//               ^^^^^^^ Unity 的球谐函数，根据法线方向采样环境光</span>
 <span class="cm">/******************镜面反射环境光*********************/</span>
 <span class="c1">//1.采样反射探针（Reflection Probe）</span>
 <span class="n">half4</span> <span class="n">skyData</span> <span class="o">=</span> <span class="n">UNITY_SAMPLE_TEXCUBE</span><span class="p">(</span><span class="n">unity_SpecCube0</span><span class="p">,</span> <span class="n">reflectDir</span><span class="p">);</span>
 <span class="n">half3</span> <span class="n">skyColor</span> <span class="o">=</span> <span class="n">DecodeHDR</span><span class="p">(</span><span class="n">skyData</span><span class="p">,</span> <span class="n">unity_SpecCube0_HDR</span><span class="p">);</span>
        
    <span class="c1">//2. 采样Cubemap</span>
    <span class="c1">// 计算反射方向</span>
    <span class="n">float3</span> <span class="n">reflviewDir</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">viewDir</span><span class="p">,</span> <span class="n">normalize</span><span class="p">(</span><span class="n">positionWS</span><span class="p">));</span>
    <span class="c1">//half4 reflColor = texCUBE(_CubeMap, reflviewDir);</span>
    <span class="n">half4</span> <span class="n">reflColor</span> <span class="o">=</span> <span class="n">texCUBElod</span><span class="p">(</span><span class="n">_CubeMap</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="n">reflectDir</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">half3</span> <span class="n">reflRGB</span> <span class="o">=</span> <span class="n">DecodeHDR</span><span class="p">(</span><span class="n">reflColor</span><span class="p">,</span> <span class="n">_CubeMap_HDR</span><span class="p">);</span>
    <span class="c1">//AO控制</span>
    <span class="kt">float</span> <span class="n">fakeAO</span> <span class="o">=</span> <span class="n">saturate</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">normalWS</span><span class="p">,</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)));</span>
    <span class="n">reflRGB</span> <span class="o">*=</span> <span class="n">fakeAO</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">finalEnvColor</span> <span class="o">=</span> <span class="n">envColorSH</span> <span class="o">+</span>  <span class="n">reflRGB</span><span class="p">;</span>

    <span class="c1">//Shadow</span>
    <span class="kt">float</span> <span class="n">shadow</span> <span class="o">=</span> <span class="n">SHADOW_ATTENUATION</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

    <span class="c1">//output</span>
    <span class="n">float3</span> <span class="n">finalColor</span> <span class="o">=</span> <span class="n">baseCol</span> <span class="o">*</span> <span class="n">halfLambet</span> <span class="o">*</span> <span class="n">lightColor</span> <span class="o">*</span> <span class="n">shadow</span> <span class="o">+</span> <span class="n">blinnPhongSpecular</span><span class="o">*</span> <span class="n">shadow</span> <span class="o">+</span> <span class="n">finalEnvColor</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">float4</span><span class="p">(</span><span class="n">finalColor</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> 
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>]]></content><author><name></name></author><category term="TAMonth01"/><category term="shader"/><category term="rendering"/><category term="unity"/><summary type="html"><![CDATA[如何添加环境光]]></summary></entry></feed>